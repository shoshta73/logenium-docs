<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logenium - debug: Debug Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logenium - debug
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__debug.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Debug Module</div></div>
</div><!--header-->
<div class="contents">

<p>Debug utilities for development and diagnostics.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Debug Module:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__debug.svg" width="355" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__debug-internal" id="r_group__debug-internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug-internal.html">Internal Implementation</a></td></tr>
<tr class="memdesc:group__debug-internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation details for the debug module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3d67274039a14c014deacb51040acd3b" id="r_ga3d67274039a14c014deacb51040acd3b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga3d67274039a14c014deacb51040acd3b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__debug.html#ga3d67274039a14c014deacb51040acd3b">debug::Assert</a> = <a class="el" href="structdebug_1_1detail_1_1AssertImpl.html">detail::AssertImpl</a>&lt; Args... &gt;</td></tr>
<tr class="memdesc:ga3d67274039a14c014deacb51040acd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime assertion with formatted messages, source location, and stack traces.  <br /></td></tr>
<tr class="separator:ga3d67274039a14c014deacb51040acd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga68232c18b497bd8c492f3094d2957991" id="r_ga68232c18b497bd8c492f3094d2957991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#ga68232c18b497bd8c492f3094d2957991">debug::Breakpoint</a> ()</td></tr>
<tr class="memdesc:ga68232c18b497bd8c492f3094d2957991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers a debugger breakpoint unconditionally (debug builds only).  <br /></td></tr>
<tr class="separator:ga68232c18b497bd8c492f3094d2957991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10ae5d61410609b63c15a98f9fe938b" id="r_gab10ae5d61410609b63c15a98f9fe938b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b">debug::BreakpointIfDebugging</a> ()</td></tr>
<tr class="memdesc:gab10ae5d61410609b63c15a98f9fe938b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers a debugger breakpoint only if a debugger is currently attached.  <br /></td></tr>
<tr class="separator:gab10ae5d61410609b63c15a98f9fe938b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe3e9201167c10ae6307648dc9f18d18" id="r_gafe3e9201167c10ae6307648dc9f18d18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18">debug::IsDebuggerPresent</a> ()</td></tr>
<tr class="memdesc:gafe3e9201167c10ae6307648dc9f18d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the process is currently running under a debugger.  <br /></td></tr>
<tr class="separator:gafe3e9201167c10ae6307648dc9f18d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Debug utilities for development and diagnostics. </p>
<p>The debug module provides essential debugging tools that help during development:</p><ul>
<li><b>Breakpoints</b>: Trigger debugger breakpoints for inspection</li>
<li><b>Assertions</b>: Runtime checks with detailed diagnostics and stack traces</li>
<li><b>Debugger detection</b>: Check if running under a debugger</li>
</ul>
<p>All debug utilities are designed to have minimal or zero overhead in release builds:</p><ul>
<li>Breakpoint() becomes a consteval no-op in release mode (NDEBUG defined)</li>
<li>Assert() checks are completely removed in release builds</li>
<li>IsDebuggerPresent() remains available in all builds for runtime behavior changes</li>
</ul>
<h2><a class="anchor" id="autotoc_md0"></a>
Components</h2>
<h3><a class="anchor" id="autotoc_md1"></a>
Breakpoints</h3>
<ul>
<li><code>Breakpoint()</code>: Unconditionally trigger a debugger breakpoint (debug builds only)</li>
<li><code>BreakpointIfDebugging()</code>: Conditionally break only if debugger is attached</li>
</ul>
<h3><a class="anchor" id="autotoc_md2"></a>
Assertions</h3>
<ul>
<li><code>Assert()</code>: Runtime checks with formatted messages and stack traces</li>
</ul>
<h3><a class="anchor" id="autotoc_md3"></a>
Debugger Detection</h3>
<ul>
<li><code>IsDebuggerPresent()</code>: Check if the process is running under a debugger</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Usage</h2>
<p>Include the convenience header to get all debug utilities: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hxx.html">debug.hxx</a>&gt;</span></div>
<div class="ttc" id="adebug_8hxx_html"><div class="ttname"><a href="debug_8hxx.html">debug.hxx</a></div><div class="ttdoc">Convenience header for all debug module components.</div></div>
</div><!-- fragment --><p>Or include specific headers: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="breakpoint_8hxx.html">debug/breakpoint.hxx</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hxx.html">debug/assert.hxx</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__debugger__present_8hxx.html">debug/is_debugger_present.hxx</a>&gt;</span></div>
<div class="ttc" id="aassert_8hxx_html"><div class="ttname"><a href="assert_8hxx.html">assert.hxx</a></div></div>
<div class="ttc" id="abreakpoint_8hxx_html"><div class="ttname"><a href="breakpoint_8hxx.html">breakpoint.hxx</a></div></div>
<div class="ttc" id="ais__debugger__present_8hxx_html"><div class="ttname"><a href="is__debugger__present_8hxx.html">is_debugger_present.hxx</a></div></div>
</div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3d67274039a14c014deacb51040acd3b" name="ga3d67274039a14c014deacb51040acd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d67274039a14c014deacb51040acd3b">&#9670;&#160;</a></span>Assert</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__debug.html#ga3d67274039a14c014deacb51040acd3b">debug::Assert</a> = typedef <a class="el" href="structdebug_1_1detail_1_1AssertImpl.html">detail::AssertImpl</a>&lt;Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime assertion with formatted messages, source location, and stack traces. </p>
<p>Assert provides enhanced runtime checking with detailed diagnostic output. Unlike standard <code>&lt;cassert&gt;</code>, it supports formatted messages, automatically captures source location and stack traces, and can optionally break into the debugger before aborting.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Usage</h2>
<p>Assertions are created using brace initialization syntax: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structdebug_1_1detail_1_1AssertImpl.html">debug::Assert</a>{condition, <span class="stringliteral">&quot;format string&quot;</span>, args...};</div>
<div class="ttc" id="astructdebug_1_1detail_1_1AssertImpl_html"><div class="ttname"><a href="structdebug_1_1detail_1_1AssertImpl.html">debug::detail::AssertImpl</a></div><div class="ttdoc">Implementation class for runtime assertions with formatted messages and diagnostics.</div><div class="ttdef"><b>Definition</b> assert.hxx:84</div></div>
</div><!-- fragment --><p>The assertion checks <code>condition</code> and, if false:</p><ol type="1">
<li>Prints the formatted message with source location and stack trace</li>
<li>Calls <code><a class="el" href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b" title="Triggers a debugger breakpoint only if a debugger is currently attached.">BreakpointIfDebugging()</a></code> to break if a debugger is attached</li>
<li>Calls <code>std::abort()</code> to terminate the program</li>
</ol>
<h2><a class="anchor" id="autotoc_md6"></a>
Build Configurations</h2>
<p>The implementation adapts to different build configurations:</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Debug vs Release</h3>
<ul>
<li><b>Debug builds</b> (<code>NDEBUG</code> not defined): Full assertion checking with diagnostics</li>
<li><b>Release builds</b> (<code>NDEBUG</code> defined): Constexpr no-op, completely optimized away</li>
</ul>
<h3><a class="anchor" id="autotoc_md8"></a>
Formatting Library</h3>
<ul>
<li><b>Standard library</b> (default): Uses <code>std::format</code> and <code>std::println</code></li>
<li><b>fmtlib</b> (<code>LOGENIUM_DEBUG_USE_FMTLIB=ON</code>): Uses <code>fmt::format</code> and <code>fmt::println</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md9"></a>
Colored Output</h3>
<ul>
<li><b>Disabled</b> (default): Plain text output</li>
<li><b>Enabled</b> (<code>LOGENIUM_DEBUG_USE_COLOR_LOGS=ON</code>, requires fmtlib): "Assertion failed" highlighted with red background and white text</li>
</ul>
<h3><a class="anchor" id="autotoc_md10"></a>
Stack Trace Format</h3>
<ul>
<li><b>Reversed</b> (default): Stack frames printed in reverse order (most recent last)</li>
<li><b>Fast</b> (<code>LOGENIUM_DEBUG_USE_FAST_STACKTRACE=ON</code>): Stack frames in natural order</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
Examples</h2>
<div class="fragment"><div class="line"><span class="comment">// Simple assertion with message</span></div>
<div class="line"><span class="keywordtype">void</span> process(<span class="keywordtype">int</span> *ptr) {</div>
<div class="line">    <a class="code hl_struct" href="structdebug_1_1detail_1_1AssertImpl.html">debug::Assert</a>{ptr != <span class="keyword">nullptr</span>, <span class="stringliteral">&quot;Null pointer passed to process()&quot;</span>};</div>
<div class="line">    <span class="comment">// ... use ptr safely ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Assertion with formatted message</span></div>
<div class="line"><span class="keywordtype">void</span> set_value(<span class="keywordtype">int</span> value) {</div>
<div class="line">    <a class="code hl_struct" href="structdebug_1_1detail_1_1AssertImpl.html">debug::Assert</a>{value &gt;= 0 &amp;&amp; value &lt;= 100,</div>
<div class="line">                  <span class="stringliteral">&quot;Value {} out of range [0, 100]&quot;</span>, value};</div>
<div class="line">    <span class="comment">// ... proceed with valid value ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Complex condition with detailed diagnostics</span></div>
<div class="line"><span class="keywordtype">void</span> transfer(Account &amp;from, Account &amp;to, <span class="keywordtype">double</span> amount) {</div>
<div class="line">    <a class="code hl_struct" href="structdebug_1_1detail_1_1AssertImpl.html">debug::Assert</a>{from.balance &gt;= amount,</div>
<div class="line">                  <span class="stringliteral">&quot;Insufficient funds: account {} has ${:.2f}, need ${:.2f}&quot;</span>,</div>
<div class="line">                  from.id, from.balance, amount};</div>
<div class="line">    <span class="comment">// ... perform transfer ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Mathematical invariant checking</span></div>
<div class="line"><span class="keywordtype">int</span> divide(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">    <a class="code hl_struct" href="structdebug_1_1detail_1_1AssertImpl.html">debug::Assert</a>{b != 0, <span class="stringliteral">&quot;Division by zero: {} / {}&quot;</span>, a, b};</div>
<div class="line">    <span class="keywordflow">return</span> a / b;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Why Use Assert Over &lt;cassert&gt;?</h2>
<ul>
<li><b>Formatted messages</b>: Use modern formatting instead of plain strings</li>
<li><b>Automatic context</b>: Source location captured without manual <code>__FILE__</code>/<code>__LINE__</code></li>
<li><b>Stack traces</b>: See the full call chain leading to the failure</li>
<li><b>Debugger integration</b>: Automatically breaks if a debugger is attached</li>
<li><b>Better diagnostics</b>: Clear, formatted output helps debug issues faster</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variadic template parameters for format arguments (deduced automatically)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always prefer <code><a class="el" href="group__debug.html#ga3d67274039a14c014deacb51040acd3b" title="Runtime assertion with formatted messages, source location, and stack traces.">debug::Assert</a></code> over <code>&lt;cassert&gt;</code> in this codebase for better diagnostics and debugger integration.</dd>
<dd>
In release builds, assertions compile away completely with zero overhead.</dd>
<dd>
Source location and stack traces are captured automatically at the assertion site, not at the AssertImpl constructor site.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b" title="Triggers a debugger breakpoint only if a debugger is currently attached.">BreakpointIfDebugging()</a> for the automatic debugger breaking behavior </dd>
<dd>
<a class="el" href="structdebug_1_1detail_1_1AssertImpl.html" title="Implementation class for runtime assertions with formatted messages and diagnostics.">detail::AssertImpl</a> for implementation details </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga68232c18b497bd8c492f3094d2957991" name="ga68232c18b497bd8c492f3094d2957991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68232c18b497bd8c492f3094d2957991">&#9670;&#160;</a></span>Breakpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void debug::Breakpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers a debugger breakpoint unconditionally (debug builds only). </p>
<p>When called in debug builds, this function halts execution and transfers control to an attached debugger at the point of invocation. This allows developers to inspect program state, variables, and call stacks interactively.</p>
<p>The implementation uses platform-specific mechanisms to trigger the breakpoint:</p><ul>
<li><b>Clang/GCC</b>: <code>__builtin_debugtrap()</code> (preferred, generates optimal code)</li>
<li><b>MSVC</b>: <code>__debugbreak()</code> intrinsic</li>
<li><b>Windows (fallback)</b>: <code>DebugBreak()</code> Windows API function</li>
<li><b>POSIX (fallback)</b>: <code>std::raise(SIGTRAP)</code> signal</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In release builds (when NDEBUG is defined), this function becomes a consteval no-op that compiles away completely, resulting in zero runtime overhead.</dd>
<dd>
If no debugger is attached when this function is called, the behavior depends on the platform:<ul>
<li><b>Windows</b>: The system displays a "Just-In-Time Debugging" dialog</li>
<li><b>POSIX</b>: The process receives SIGTRAP and may terminate if not handled</li>
</ul>
</dd>
<dd>
For conditional breakpoints that only trigger when a debugger is attached, use <code><a class="el" href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b" title="Triggers a debugger breakpoint only if a debugger is currently attached.">BreakpointIfDebugging()</a></code> instead.</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> investigate_bug(<span class="keywordtype">int</span> value) {</div>
<div class="line">    <span class="keywordflow">if</span> (value &lt; 0) {</div>
<div class="line">        <span class="comment">// Always break here in debug builds to inspect why value is negative</span></div>
<div class="line">        <a class="code hl_function" href="group__debug.html#ga68232c18b497bd8c492f3094d2957991">debug::Breakpoint</a>();</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// ... rest of function ...</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__debug_html_ga68232c18b497bd8c492f3094d2957991"><div class="ttname"><a href="group__debug.html#ga68232c18b497bd8c492f3094d2957991">debug::Breakpoint</a></div><div class="ttdeci">void Breakpoint()</div><div class="ttdoc">Triggers a debugger breakpoint unconditionally (debug builds only).</div><div class="ttdef"><b>Definition</b> breakpoint.cxx:18</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Example: Break at a specific iteration during debugging</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">    <span class="keywordflow">if</span> (i == 42) {</div>
<div class="line">        <a class="code hl_function" href="group__debug.html#ga68232c18b497bd8c492f3094d2957991">debug::Breakpoint</a>();  <span class="comment">// Inspect state at iteration 42</span></div>
<div class="line">    }</div>
<div class="line">    process(i);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b" title="Triggers a debugger breakpoint only if a debugger is currently attached.">BreakpointIfDebugging()</a> for conditional breakpoints </dd>
<dd>
<a class="el" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18" title="Checks whether the process is currently running under a debugger.">IsDebuggerPresent()</a> to check if a debugger is attached before breaking </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__debug_ga68232c18b497bd8c492f3094d2957991_icgraph.svg" width="420" height="102"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="gab10ae5d61410609b63c15a98f9fe938b" name="gab10ae5d61410609b63c15a98f9fe938b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10ae5d61410609b63c15a98f9fe938b">&#9670;&#160;</a></span>BreakpointIfDebugging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void debug::BreakpointIfDebugging </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers a debugger breakpoint only if a debugger is currently attached. </p>
<p>This is a convenience function that combines <code><a class="el" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18" title="Checks whether the process is currently running under a debugger.">IsDebuggerPresent()</a></code> and <code><a class="el" href="group__debug.html#ga68232c18b497bd8c492f3094d2957991" title="Triggers a debugger breakpoint unconditionally (debug builds only).">Breakpoint()</a></code> to provide safe, conditional breakpoints. It checks if a debugger is attached and only triggers a breakpoint if one is present, avoiding unwanted behavior when running without a debugger.</p>
<p>In debug builds, this function:</p><ol type="1">
<li>Calls <code><a class="el" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18" title="Checks whether the process is currently running under a debugger.">IsDebuggerPresent()</a></code> to check for an attached debugger</li>
<li>If a debugger is present, calls <code><a class="el" href="group__debug.html#ga68232c18b497bd8c492f3094d2957991" title="Triggers a debugger breakpoint unconditionally (debug builds only).">Breakpoint()</a></code> to halt execution</li>
<li>If no debugger is attached, returns immediately without side effects</li>
</ol>
<p>This is particularly useful for:</p><ul>
<li><b>Assertion-like breakpoints</b>: Break on unexpected conditions during debugging, but allow normal execution in production or when running tests</li>
<li><b>Safe breakpoints in automated tests</b>: Place breakpoints that won't crash test runs</li>
<li><b>Conditional debugging</b>: Break at specific code points only when actively debugging</li>
<li><b>Development convenience</b>: Leave debugging breakpoints in code that won't affect non-debugging workflows</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In release builds (when NDEBUG is defined), this function becomes a consteval no-op that compiles away completely, resulting in zero runtime overhead.</dd>
<dd>
Unlike <code><a class="el" href="group__debug.html#ga68232c18b497bd8c492f3094d2957991" title="Triggers a debugger breakpoint unconditionally (debug builds only).">Breakpoint()</a></code>, this function is safe to call in any context (tests, production debug builds, etc.) because it only breaks when a debugger is actually attached.</dd>
<dd>
On platforms where <code><a class="el" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18" title="Checks whether the process is currently running under a debugger.">IsDebuggerPresent()</a></code> always returns <code>false</code> (currently Linux/POSIX), this function will never trigger a breakpoint, effectively becoming a no-op.</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> process_transaction(<span class="keyword">const</span> Transaction &amp;txn) {</div>
<div class="line">    <span class="keywordflow">if</span> (!txn.is_valid()) {</div>
<div class="line">        <span class="comment">// Break here during development to inspect invalid transactions,</span></div>
<div class="line">        <span class="comment">// but allow tests and production to continue</span></div>
<div class="line">        <a class="code hl_function" href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b">debug::BreakpointIfDebugging</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Handle error gracefully</span></div>
<div class="line">        log_error(<span class="stringliteral">&quot;Invalid transaction&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// ... process transaction ...</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__debug_html_gab10ae5d61410609b63c15a98f9fe938b"><div class="ttname"><a href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b">debug::BreakpointIfDebugging</a></div><div class="ttdeci">void BreakpointIfDebugging()</div><div class="ttdoc">Triggers a debugger breakpoint only if a debugger is currently attached.</div><div class="ttdef"><b>Definition</b> breakpoint_if_debugging.cxx:13</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Example: Debug a specific iteration without affecting test runs</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; items.size(); ++i) {</div>
<div class="line">    <span class="keywordflow">if</span> (i == 42) {</div>
<div class="line">        <span class="comment">// When debugging, break at iteration 42 to inspect state.</span></div>
<div class="line">        <span class="comment">// When running tests, this does nothing.</span></div>
<div class="line">        <a class="code hl_function" href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b">debug::BreakpointIfDebugging</a>();</div>
<div class="line">    }</div>
<div class="line">    process(items[i]);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Example: Safe assertion-like breakpoint for development</span></div>
<div class="line"><span class="keyword">class </span>Cache {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> insert(<span class="keyword">const</span> Key &amp;key, <span class="keyword">const</span> Value &amp;value) {</div>
<div class="line">        <span class="keywordflow">if</span> (map.contains(key)) {</div>
<div class="line">            <span class="comment">// This shouldn&#39;t happen, but if it does during debugging,</span></div>
<div class="line">            <span class="comment">// break so we can investigate. In tests/production, continue.</span></div>
<div class="line">            <a class="code hl_function" href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b">debug::BreakpointIfDebugging</a>();</div>
<div class="line">        }</div>
<div class="line">        map[key] = value;</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unordered_map&lt;Key, Value&gt; map;</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__debug.html#ga68232c18b497bd8c492f3094d2957991" title="Triggers a debugger breakpoint unconditionally (debug builds only).">Breakpoint()</a> for unconditional breakpoints </dd>
<dd>
<a class="el" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18" title="Checks whether the process is currently running under a debugger.">IsDebuggerPresent()</a> to check debugger state without breaking </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__debug_gab10ae5d61410609b63c15a98f9fe938b_cgraph.svg" width="472" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="gafe3e9201167c10ae6307648dc9f18d18" name="gafe3e9201167c10ae6307648dc9f18d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe3e9201167c10ae6307648dc9f18d18">&#9670;&#160;</a></span>IsDebuggerPresent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool debug::IsDebuggerPresent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the process is currently running under a debugger. </p>
<p>This function detects if a debugger is attached to the current process at the time of invocation. It can be used to conditionally enable debugging features, modify behavior for better debugging experience, or trigger breakpoints only when actively debugging.</p>
<p>The implementation uses platform-specific mechanisms:</p><ul>
<li><b>Windows</b>: Calls the Windows API <code><a class="el" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18" title="Checks whether the process is currently running under a debugger.">IsDebuggerPresent()</a></code> function, which checks the PEB (Process Environment Block) <code>BeingDebugged</code> flag</li>
<li><b>Linux/POSIX</b>: Currently returns <code>false</code> (stub implementation)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a debugger is currently attached to the process, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In release builds (when NDEBUG is defined), this function becomes a consteval function that always returns <code>false</code>, allowing the compiler to optimize away debugging-specific code paths completely.</dd>
<dd>
The result reflects the debugger state at the moment of the call. A debugger can attach or detach at any time, so the result may change between calls.</dd>
<dd>
On Windows, this function is reliable and accurate. On Linux/POSIX platforms, the current implementation is a stub and always returns <code>false</code>. Full support for Linux debugger detection may be added in future versions.</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> log_message(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18">debug::IsDebuggerPresent</a>()) {</div>
<div class="line">        <span class="comment">// When debugging, output detailed diagnostic information</span></div>
<div class="line">        std::println(stderr, <span class="stringliteral">&quot;[DEBUG] {}: {}&quot;</span>, __func__, msg);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// In normal execution, use standard logging</span></div>
<div class="line">        std::println(<span class="stringliteral">&quot;{}&quot;</span>, msg);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__debug_html_gafe3e9201167c10ae6307648dc9f18d18"><div class="ttname"><a href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18">debug::IsDebuggerPresent</a></div><div class="ttdeci">bool IsDebuggerPresent()</div><div class="ttdoc">Checks whether the process is currently running under a debugger.</div><div class="ttdef"><b>Definition</b> is_debugger_present.cxx:12</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Example: Conditional breakpoint based on debugger presence</span></div>
<div class="line"><span class="keywordtype">void</span> process_critical_data(<span class="keyword">const</span> Data &amp;data) {</div>
<div class="line">    <span class="keywordflow">if</span> (!validate(data)) {</div>
<div class="line">        <span class="comment">// Only break if we&#39;re actually debugging</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18">debug::IsDebuggerPresent</a>()) {</div>
<div class="line">            <a class="code hl_function" href="group__debug.html#ga68232c18b497bd8c492f3094d2957991">debug::Breakpoint</a>();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Log error and continue in production</span></div>
<div class="line">            log_error(<span class="stringliteral">&quot;Invalid data detected&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Example: Enable verbose tracing only when debugging</span></div>
<div class="line"><span class="keyword">class </span>Component {</div>
<div class="line">    <span class="keywordtype">bool</span> verbose_trace = <a class="code hl_function" href="group__debug.html#gafe3e9201167c10ae6307648dc9f18d18">debug::IsDebuggerPresent</a>();</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> process() {</div>
<div class="line">        <span class="keywordflow">if</span> (verbose_trace) {</div>
<div class="line">            std::println(<span class="stringliteral">&quot;Processing step 1...&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// ... processing logic ...</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__debug.html#gab10ae5d61410609b63c15a98f9fe938b" title="Triggers a debugger breakpoint only if a debugger is currently attached.">BreakpointIfDebugging()</a> which combines this check with <a class="el" href="group__debug.html#ga68232c18b497bd8c492f3094d2957991" title="Triggers a debugger breakpoint unconditionally (debug builds only).">Breakpoint()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__debug_gafe3e9201167c10ae6307648dc9f18d18_icgraph.svg" width="472" height="102"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
