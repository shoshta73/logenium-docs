<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logenium - corelib: Internal Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logenium - corelib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__casting__detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Internal Implementation<div class="ingroups"><a class="el" href="group__casting.html">Casting Module</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Internal implementation details of the casting module.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Internal Implementation:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__casting__detail.svg" width="362" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1UniquePtrCast.html">corelib::detail::UniquePtrCast&lt; To, From, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casting adapter for std::unique_ptr with ownership transfer.  <a href="structcorelib_1_1detail_1_1UniquePtrCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1OptionalValueCast.html">corelib::detail::OptionalValueCast&lt; To, From, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casting adapter for optional-returning casts.  <a href="structcorelib_1_1detail_1_1OptionalValueCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1ValueFromPointerCast.html">corelib::detail::ValueFromPointerCast&lt; To, From, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casting adapter for converting pointers to values.  <a href="structcorelib_1_1detail_1_1ValueFromPointerCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastRettyImpl.html">corelib::detail::CastRettyImpl&lt; To, From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for calculating cast return types.  <a href="structcorelib_1_1detail_1_1CastRettyImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01const_01From_01_4.html">corelib::detail::CastRettyImpl&lt; To, const From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for const-qualified types.  <a href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01const_01From_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01From_01_5_01_4.html">corelib::detail::CastRettyImpl&lt; To, From * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for pointer types.  <a href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01From_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01const_01From_01_5_01_4.html">corelib::detail::CastRettyImpl&lt; To, const From * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for pointer-to-const types.  <a href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01const_01From_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01const_01From_01_5const_01_4.html">corelib::detail::CastRettyImpl&lt; To, const From *const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for const-pointer-to-const types.  <a href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01const_01From_01_5const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01std_1_1unique__ptr_3_01From_01_4_01_4.html">corelib::detail::CastRettyImpl&lt; To, std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::unique_ptr types.  <a href="structcorelib_1_1detail_1_1CastRettyImpl_3_01To_00_01std_1_1unique__ptr_3_01From_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastRettyWrap.html">corelib::detail::CastRettyWrap&lt; To, From, SimpleFrom &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive wrapper for return type calculation with type simplification.  <a href="structcorelib_1_1detail_1_1CastRettyWrap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastRettyWrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">corelib::detail::CastRettyWrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for fully simplified types (base case).  <a href="structcorelib_1_1detail_1_1CastRettyWrap_3_01To_00_01FromTy_00_01FromTy_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastRetty.html">corelib::detail::CastRetty&lt; To, From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main return type calculator with type simplification.  <a href="structcorelib_1_1detail_1_1CastRetty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastIsPossible.html">corelib::detail::CastIsPossible&lt; To, From, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for checking if a cast is possible.  <a href="structcorelib_1_1detail_1_1CastIsPossible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastIsPossible_3_01To_00_01std_1_1optional_3_01From_01_4_01_4.html">corelib::detail::CastIsPossible&lt; To, std::optional&lt; From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::optional types.  <a href="structcorelib_1_1detail_1_1CastIsPossible_3_01To_00_01std_1_1optional_3_01From_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastIsPossible_3_01To_00_01From_00_01std_1_1enable__if__t_3_01std_1_13035afbf33027b5f9ca245b90dd094bb.html">corelib::detail::CastIsPossible&lt; To, From, std::enable_if_t&lt; std::is_base_of_v&lt; To, From &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for trivial upcasts (From derives from To).  <a href="structcorelib_1_1detail_1_1CastIsPossible_3_01To_00_01From_00_01std_1_1enable__if__t_3_01std_1_13035afbf33027b5f9ca245b90dd094bb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastConvertVal.html">corelib::detail::CastConvertVal&lt; To, From, SimpleFrom &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive cast conversion with type simplification.  <a href="structcorelib_1_1detail_1_1CastConvertVal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastConvertVal_3_01To_00_01FromTy_00_01FromTy_01_4.html">corelib::detail::CastConvertVal&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for fully simplified reference types (base case).  <a href="structcorelib_1_1detail_1_1CastConvertVal_3_01To_00_01FromTy_00_01FromTy_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastConvertVal_3_01To_00_01FromTy_01_5_00_01FromTy_01_5_01_4.html">corelib::detail::CastConvertVal&lt; To, FromTy *, FromTy * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for pointer types.  <a href="structcorelib_1_1detail_1_1CastConvertVal_3_01To_00_01FromTy_01_5_00_01FromTy_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastInfo.html">corelib::detail::CastInfo&lt; To, From, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main orchestrator for cast operations.  <a href="structcorelib_1_1detail_1_1CastInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastInfo_3_01To_00_01From_00_01std_1_1enable__if__t_3_9IsSimpleType_3_01From_01_4_1_1value_01_4_01_4.html">corelib::detail::CastInfo&lt; To, From, std::enable_if_t&lt;!IsSimpleType&lt; From &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for non-simple types requiring simplification.  <a href="structcorelib_1_1detail_1_1CastInfo_3_01To_00_01From_00_01std_1_1enable__if__t_3_9IsSimpleType_3_01From_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastInfo_3_01To_00_01std_1_1unique__ptr_3_01From_01_4_01_4.html">corelib::detail::CastInfo&lt; To, std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::unique_ptr types.  <a href="structcorelib_1_1detail_1_1CastInfo_3_01To_00_01std_1_1unique__ptr_3_01From_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastInfo_3_01To_00_01std_1_1optional_3_01From_01_4_01_4.html">corelib::detail::CastInfo&lt; To, std::optional&lt; From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::optional types.  <a href="structcorelib_1_1detail_1_1CastInfo_3_01To_00_01std_1_1optional_3_01From_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1NullableValueCastFailed.html">corelib::detail::NullableValueCastFailed&lt; To &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides default <a class="el" href="structcorelib_1_1detail_1_1NullableValueCastFailed.html#a161f787c8955b2071abd11ca070a1cc1">CastFailed()</a> implementation for nullable types.  <a href="structcorelib_1_1detail_1_1NullableValueCastFailed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1DefaultDoCastIfPossible.html">corelib::detail::DefaultDoCastIfPossible&lt; To, From, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base providing default <a class="el" href="structcorelib_1_1detail_1_1DefaultDoCastIfPossible.html#a91348def46d438c466605c0d2644a949">DoCastIfPossible()</a> implementation.  <a href="structcorelib_1_1detail_1_1DefaultDoCastIfPossible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1ForwardToPointerCast.html">corelib::detail::ForwardToPointerCast&lt; To, From, ForwardTo &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards reference-based casts to pointer-based cast implementations.  <a href="structcorelib_1_1detail_1_1ForwardToPointerCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1ConstStrippingForwardingCast.html">corelib::detail::ConstStrippingForwardingCast&lt; To, From, ForwardTo &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards const-qualified casts to non-const cast implementations.  <a href="structcorelib_1_1detail_1_1ConstStrippingForwardingCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImpl.html">corelib::detail::IsaImpl&lt; To, From, Enabler &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for RTTI-free type checking using classof() pattern.  <a href="structcorelib_1_1detail_1_1IsaImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImpl_3_01To_00_01From_00_01std_1_1enable__if__t_3_01std_1_1is__basf7039fd9a4408d3b8d789b56a96e7879.html">corelib::detail::IsaImpl&lt; To, From, std::enable_if_t&lt; std::is_base_of_v&lt; To, From &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when From is derived from To (always true).  <a href="structcorelib_1_1detail_1_1IsaImpl_3_01To_00_01From_00_01std_1_1enable__if__t_3_01std_1_1is__basf7039fd9a4408d3b8d789b56a96e7879.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImplConst.html">corelib::detail::IsaImplConst&lt; To, From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for const-correct type checking with pointer support.  <a href="structcorelib_1_1detail_1_1IsaImplConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01const_01From_01_4.html">corelib::detail::IsaImplConst&lt; To, const From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for const-qualified types.  <a href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01const_01From_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01const_01std_1_1unique__ptr_3_01From_01_4_01_4.html">corelib::detail::IsaImplConst&lt; To, const std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for const std::unique_ptr.  <a href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01const_01std_1_1unique__ptr_3_01From_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01From_01_5_01_4.html">corelib::detail::IsaImplConst&lt; To, From * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for non-const pointer (From*).  <a href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01From_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01From_01_5const_01_4.html">corelib::detail::IsaImplConst&lt; To, From *const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for const pointer to non-const (From* const).  <a href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01From_01_5const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01const_01From_01_5_01_4.html">corelib::detail::IsaImplConst&lt; To, const From * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for pointer to const (const From*).  <a href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01const_01From_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01const_01From_01_5const_01_4.html">corelib::detail::IsaImplConst&lt; To, const From *const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for const pointer to const (const From* const).  <a href="structcorelib_1_1detail_1_1IsaImplConst_3_01To_00_01const_01From_01_5const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImplWrap.html">corelib::detail::IsaImplWrap&lt; To, From, SimpleFrom &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive type simplification wrapper for type checking.  <a href="structcorelib_1_1detail_1_1IsaImplWrap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaImplWrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">corelib::detail::IsaImplWrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for fully simplified types (base case).  <a href="structcorelib_1_1detail_1_1IsaImplWrap_3_01To_00_01FromTy_00_01FromTy_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaCheckPredicate.html">corelib::detail::IsaCheckPredicate&lt; Types &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate functor for variadic type checking.  <a href="structcorelib_1_1detail_1_1IsaCheckPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsaAndPresentCheckPredicate.html">corelib::detail::IsaAndPresentCheckPredicate&lt; Types &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate functor for type checking with presence validation.  <a href="structcorelib_1_1detail_1_1IsaAndPresentCheckPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1StaticCastFunc.html">corelib::detail::StaticCastFunc&lt; U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for static_cast operations.  <a href="structcorelib_1_1detail_1_1StaticCastFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1DynCastFunc.html">corelib::detail::DynCastFunc&lt; U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for dyn_cast operations.  <a href="structcorelib_1_1detail_1_1DynCastFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastFunc.html">corelib::detail::CastFunc&lt; U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for cast operations.  <a href="structcorelib_1_1detail_1_1CastFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1CastIfPresentFunc.html">corelib::detail::CastIfPresentFunc&lt; U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for conditional cast operations.  <a href="structcorelib_1_1detail_1_1CastIfPresentFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1DynCastIfPresentFunc.html">corelib::detail::DynCastIfPresentFunc&lt; U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for conditional dynamic cast operations.  <a href="structcorelib_1_1detail_1_1DynCastIfPresentFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1SimplifyType.html">corelib::detail::SimplifyType&lt; From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for recursive type simplification in the casting system.  <a href="structcorelib_1_1detail_1_1SimplifyType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1SimplifyType_3_01const_01From_01_4.html">corelib::detail::SimplifyType&lt; const From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for const-qualified types that recursively unwraps const.  <a href="structcorelib_1_1detail_1_1SimplifyType_3_01const_01From_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1IsSimpleType.html">corelib::detail::IsSimpleType&lt; X &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is already in simplified form.  <a href="structcorelib_1_1detail_1_1IsSimpleType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1ValueIsPresent.html">corelib::detail::ValueIsPresent&lt; T, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for detecting value presence and unwrapping values.  <a href="structcorelib_1_1detail_1_1ValueIsPresent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1ValueIsPresent_3_01std_1_1optional_3_01T_01_4_01_4.html">corelib::detail::ValueIsPresent&lt; std::optional&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::optional&lt;T&gt; that checks <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">has_value()</a> and unwraps.  <a href="structcorelib_1_1detail_1_1ValueIsPresent_3_01std_1_1optional_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1detail_1_1ValueIsPresent_3_01T_00_01std_1_1enable__if__t_3_01detail_1_1IsNullable_3_01T_01_4_01_4_01_4.html">corelib::detail::ValueIsPresent&lt; T, std::enable_if_t&lt; detail::IsNullable&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for nullable types (pointers and nullptr-constructible types).  <a href="structcorelib_1_1detail_1_1ValueIsPresent_3_01T_00_01std_1_1enable__if__t_3_01detail_1_1IsNullable_3_01T_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5288b08cace8d07dfba8b5ac6770ab16" id="r_ga5288b08cace8d07dfba8b5ac6770ab16"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">OptionalDerived</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Default</a> &gt; </td></tr>
<tr class="memitem:ga5288b08cace8d07dfba8b5ac6770ab16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting__detail.html#ga5288b08cace8d07dfba8b5ac6770ab16">corelib::detail::SelfType</a> = std::conditional_t&lt; std::is_same_v&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">OptionalDerived</a>, <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">void</a> &gt;, <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Default</a>, <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">OptionalDerived</a> &gt;</td></tr>
<tr class="memdesc:ga5288b08cace8d07dfba8b5ac6770ab16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type alias for CRTP pattern with optional derived class override.  <br /></td></tr>
<tr class="separator:ga5288b08cace8d07dfba8b5ac6770ab16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gace20dbc8b249b7264f6344d0e8c46333" id="r_gace20dbc8b249b7264f6344d0e8c46333"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </td></tr>
<tr class="memitem:gace20dbc8b249b7264f6344d0e8c46333"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting__detail.html#gace20dbc8b249b7264f6344d0e8c46333">corelib::detail::isPresent</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">const</a> T &amp;t)</td></tr>
<tr class="memdesc:gace20dbc8b249b7264f6344d0e8c46333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check if a value is present (not null/empty).  <br /></td></tr>
<tr class="separator:gace20dbc8b249b7264f6344d0e8c46333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a65a7cf30b59a490faf6bc1080f099" id="r_gac9a65a7cf30b59a490faf6bc1080f099"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </td></tr>
<tr class="memitem:gac9a65a7cf30b59a490faf6bc1080f099"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting__detail.html#gac9a65a7cf30b59a490faf6bc1080f099">corelib::detail::unwrapValue</a> (T &amp;t)</td></tr>
<tr class="memdesc:gac9a65a7cf30b59a490faf6bc1080f099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to unwrap a value from its container.  <br /></td></tr>
<tr class="separator:gac9a65a7cf30b59a490faf6bc1080f099"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga9ebd2ac000da5adfd8bd89ca7c7f5899" id="r_ga9ebd2ac000da5adfd8bd89ca7c7f5899"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </td></tr>
<tr class="memitem:ga9ebd2ac000da5adfd8bd89ca7c7f5899"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting__detail.html#ga9ebd2ac000da5adfd8bd89ca7c7f5899">corelib::detail::IsNullable</a> = std::is_pointer_v&lt;T&gt; || std::is_constructible_v&lt;T, std::nullptr_t&gt;</td></tr>
<tr class="memdesc:ga9ebd2ac000da5adfd8bd89ca7c7f5899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template to detect if a type can represent a null/empty state.  <br /></td></tr>
<tr class="separator:ga9ebd2ac000da5adfd8bd89ca7c7f5899"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Internal implementation details of the casting module. </p>
<p>This group contains the internal implementation machinery that powers the public casting APIs. These components use advanced template metaprogramming techniques including SFINAE, CRTP, type traits, and recursive type simplification.</p>
<p><b>Note</b>: This group documents internal implementation details. Most users should use the public API (isa, cast, dyn_cast, etc.) instead of directly using these internal components.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Architecture</h2>
<p>The implementation is organized into several layers:</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Type System (&lt;tt&gt;detail/casting/traits.hxx&lt;/tt&gt;)</h3>
<ul>
<li><code>SimplifyType&lt;T&gt;</code>: Recursive type unwrapping (removes const, references, pointers)</li>
<li><code>IsNullable&lt;T&gt;</code>: Detects nullable types (pointers, unique_ptr, optional)</li>
<li><code>ValueIsPresent&lt;T&gt;</code>: Presence checking for nullable types</li>
<li><code>isPresent()</code>, <code>unwrapValue()</code>: Helper functions for value handling</li>
<li><code>SelfType&lt;T&gt;</code>: CRTP helper for type customization</li>
</ul>
<h3><a class="anchor" id="autotoc_md10"></a>
Forwarding (&lt;tt&gt;detail/casting/forwarding.hxx&lt;/tt&gt;)</h3>
<ul>
<li><code>NullableValueCastFailed&lt;To&gt;</code>: Default failure handler</li>
<li><code>DefaultDoCastIfPossible&lt;To, From&gt;</code>: CRTP base for conditional casting</li>
<li><code>ForwardToPointerCast&lt;To, From&gt;</code>: Reference-to-pointer forwarding</li>
<li><code>ConstStrippingForwardingCast&lt;To, From&gt;</code>: Const-aware forwarding</li>
</ul>
<h3><a class="anchor" id="autotoc_md11"></a>
Type Checking (&lt;tt&gt;detail/casting/isa.hxx&lt;/tt&gt;)</h3>
<ul>
<li><code>IsaImpl&lt;To, From&gt;</code>: Core ISA implementation using classof()</li>
<li><code>IsaImplConst&lt;To, From&gt;</code>: Const and pointer handling</li>
<li><code>IsaImplWrap&lt;To, From&gt;</code>: Type simplification wrapper</li>
</ul>
<h3><a class="anchor" id="autotoc_md12"></a>
Type-Specific Adapters (&lt;tt&gt;detail/casting/adapters.hxx&lt;/tt&gt;)</h3>
<ul>
<li><code>UniquePtrCast&lt;To, From&gt;</code>: unique_ptr casting with ownership transfer</li>
<li><code>OptionalValueCast&lt;To, From&gt;</code>: Optional-returning casts</li>
<li><code>ValueFromPointerCast&lt;To, From&gt;</code>: Pointer-to-value casting</li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
Cast Infrastructure (&lt;tt&gt;detail/casting/cast.hxx&lt;/tt&gt;)</h3>
<ul>
<li><code>CastRetty&lt;To, From&gt;</code>: Return type calculation</li>
<li><code>CastIsPossible&lt;To, From&gt;</code>: Cast possibility checking</li>
<li><code>CastConvertVal&lt;To, From&gt;</code>: Cast conversion</li>
<li><code>CastInfo&lt;To, From&gt;</code>: Main cast orchestrator</li>
</ul>
<h3><a class="anchor" id="autotoc_md14"></a>
Predicate Functors (&lt;tt&gt;detail/casting/predicates.hxx&lt;/tt&gt;)</h3>
<ul>
<li><code>IsaCheckPredicate&lt;T&gt;</code>: ISA predicate implementation</li>
<li><code>IsaAndPresentCheckPredicate&lt;T&gt;</code>: Null-safe ISA predicate</li>
<li><code>StaticCastFunc&lt;T&gt;</code>, <code>CastFunc&lt;T&gt;</code>, <code>DynCastFunc&lt;T&gt;</code>: Cast functors</li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
Design Patterns</h2>
<ul>
<li><b>CRTP (Curiously Recurring Template Pattern)</b>: Used for customization points</li>
<li><b>SFINAE (Substitution Failure Is Not An Error)</b>: For conditional compilation</li>
<li><b>Type Traits</b>: Compile-time type introspection</li>
<li><b>Recursive Templates</b>: For type simplification</li>
<li><b>Template Specialization</b>: For type-specific behavior </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5288b08cace8d07dfba8b5ac6770ab16" name="ga5288b08cace8d07dfba8b5ac6770ab16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5288b08cace8d07dfba8b5ac6770ab16">&#9670;&#160;</a></span>SelfType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">OptionalDerived</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Default</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a> <a class="el" href="group__casting__detail.html#ga5288b08cace8d07dfba8b5ac6770ab16">corelib::detail::SelfType</a> = <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typedef</a> std::conditional_t&lt;std::is_same_v&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">OptionalDerived</a>, <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">void</a>&gt;, <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Default</a>, <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">OptionalDerived</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type alias for CRTP pattern with optional derived class override. </p>
<p>SelfType implements a common CRTP (Curiously Recurring Template Pattern) idiom where a base class template takes an optional derived type parameter. If the derived type is void, it defaults to a specified default type.</p>
<p>This is used extensively in the casting infrastructure to allow customization points while providing sensible defaults. Template classes can use SelfType to refer to either a user-provided derived class or themselves.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OptionalDerived</td><td>The optional derived class (or void for default) </td></tr>
    <tr><td class="paramname">Default</td><td>The default type to use when OptionalDerived is void</td></tr>
  </table>
  </dd>
</dl>
<p>Pattern: </p><div class="fragment"><div class="line"><span class="comment">// Base class using SelfType for CRTP</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From, <span class="keyword">typename</span> Derived = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">CastOperation</a> {</div>
<div class="line">    <span class="keyword">using </span>Self = <a class="code hl_typedef" href="group__casting__detail.html#ga5288b08cace8d07dfba8b5ac6770ab16">SelfType&lt;Derived, CastOperation&lt;To, From&gt;</a>&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Methods can call static_cast&lt;Self*&gt;(this) to access derived overrides</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// User can provide custom derived class</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">MyCustomCast</a> : <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">CastOperation</a>&lt;int, double, MyCustomCast&gt; {</div>
<div class="line">    <span class="comment">// Override behavior here</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or use the default (Derived = void)</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">DefaultCast</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">CastOperation&lt;int, double&gt;</a>;</div>
<div class="ttc" id="agroup__casting__detail_html_ga5288b08cace8d07dfba8b5ac6770ab16"><div class="ttname"><a href="group__casting__detail.html#ga5288b08cace8d07dfba8b5ac6770ab16">corelib::detail::SelfType</a></div><div class="ttdeci">std::conditional_t&lt; std::is_same_v&lt; OptionalDerived, void &gt;, Default, OptionalDerived &gt; SelfType</div><div class="ttdoc">Helper type alias for CRTP pattern with optional derived class override.</div><div class="ttdef"><b>Definition</b> traits.hxx:516</div></div>
<div class="ttc" id="agroup__casting_html_ga21d42fef17770f4f775ad655ab85e2b8"><div class="ttname"><a href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">corelib::isa</a></div><div class="ttdeci">bool isa(const From &amp;Val)</div><div class="ttdoc">Checks if a value is an instance of any of the specified types.</div><div class="ttdef"><b>Definition</b> isa.hxx:64</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Used by casting infrastructure classes like <a class="el" href="structcorelib_1_1detail_1_1DefaultDoCastIfPossible.html" title="CRTP base providing default DoCastIfPossible() implementation.">DefaultDoCastIfPossible</a> </dd>
<dd>
Enables customization without requiring explicit derived classes</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// When OptionalDerived is a type</span></div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;SelfType&lt;MyClass, DefaultClass&gt;, <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">MyClass</a>&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When OptionalDerived is void</span></div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;SelfType&lt;void, DefaultClass&gt;, <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">DefaultClass</a>&gt;);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="structcorelib_1_1detail_1_1DefaultDoCastIfPossible.html" title="CRTP base providing default DoCastIfPossible() implementation.">DefaultDoCastIfPossible</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">usage</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">in</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">infrastructure</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gace20dbc8b249b7264f6344d0e8c46333" name="gace20dbc8b249b7264f6344d0e8c46333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace20dbc8b249b7264f6344d0e8c46333">&#9670;&#160;</a></span>isPresent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">bool</a> corelib::detail::isPresent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">const</a> T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to check if a value is present (not null/empty). </p>
<p>This function provides a convenient interface to <a class="el" href="structcorelib_1_1detail_1_1ValueIsPresent.html#abd9526f8ddfdd2d05a144782f6627a43">ValueIsPresent::IsPresent()</a> that also handles type simplification. It first simplifies the type T (unwrapping const qualifiers), then checks presence on the simplified value.</p>
<p>Works with:</p><ul>
<li>Regular types (always present)</li>
<li>std::optional (checks <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">has_value()</a>)</li>
<li>Pointers and smart pointers (checks != nullptr)</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check (const qualifiers are automatically handled) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The value to check for presence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value is present (not null/empty), false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically handles const-qualified types via <a class="el" href="structcorelib_1_1detail_1_1SimplifyType.html" title="Base template for recursive type simplification in the casting system.">SimplifyType</a> </dd>
<dd>
Used internally by <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> and <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a></dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> x = 42;</div>
<div class="line"><span class="keyword">static_assert</span>(<a class="code hl_function" href="group__casting__detail.html#gace20dbc8b249b7264f6344d0e8c46333">isPresent</a>(x));  <span class="comment">// true - regular values always present</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> *ptr = &amp;x;</div>
<div class="line"><span class="keyword">static_assert</span>(<a class="code hl_function" href="group__casting__detail.html#gace20dbc8b249b7264f6344d0e8c46333">isPresent</a>(ptr));  <span class="comment">// true - non-null pointer</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">null_ptr</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="keyword">static_assert</span>(!<a class="code hl_function" href="group__casting__detail.html#gace20dbc8b249b7264f6344d0e8c46333">isPresent</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">null_ptr</a>));  <span class="comment">// false - null pointer</span></div>
<div class="line"> </div>
<div class="line">std::optional&lt;int&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a> = 42;</div>
<div class="line"><span class="keyword">static_assert</span>(<a class="code hl_function" href="group__casting__detail.html#gace20dbc8b249b7264f6344d0e8c46333">isPresent</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a>));  <span class="comment">// true - optional has value</span></div>
<div class="line"> </div>
<div class="line">std::optional&lt;int&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">empty</a>;</div>
<div class="line"><span class="keyword">static_assert</span>(!<a class="code hl_function" href="group__casting__detail.html#gace20dbc8b249b7264f6344d0e8c46333">isPresent</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">empty</a>));  <span class="comment">// false - optional is empty</span></div>
<div class="ttc" id="agroup__casting__detail_html_gace20dbc8b249b7264f6344d0e8c46333"><div class="ttname"><a href="group__casting__detail.html#gace20dbc8b249b7264f6344d0e8c46333">corelib::detail::isPresent</a></div><div class="ttdeci">bool isPresent(const T &amp;t)</div><div class="ttdoc">Helper function to check if a value is present (not null/empty).</div><div class="ttdef"><b>Definition</b> traits.hxx:417</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="structcorelib_1_1detail_1_1ValueIsPresent.html" title="Base template for detecting value presence and unwrapping values.">ValueIsPresent</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">the</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">underlying</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">presence</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">mechanism</a> </dd>
<dd>
<a class="el" href="group__casting__detail.html#gac9a65a7cf30b59a490faf6bc1080f099" title="Helper function to unwrap a value from its container.">unwrapValue()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">extracting</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">the</a> value <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">after</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">presence</a> </dd></dl>

</div>
</div>
<a id="gac9a65a7cf30b59a490faf6bc1080f099" name="gac9a65a7cf30b59a490faf6bc1080f099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9a65a7cf30b59a490faf6bc1080f099">&#9670;&#160;</a></span>unwrapValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>) corelib::detail::unwrapValue </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to unwrap a value from its container. </p>
<p>This function provides a convenient interface to <a class="el" href="structcorelib_1_1detail_1_1ValueIsPresent.html#a41d172b943039df431c1e3ecc98eb7b2">ValueIsPresent::UnwrapValue()</a>. For most types, this is an identity operation (returns the value unchanged). For std::optional, it dereferences to get the contained value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to unwrap </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The value to unwrap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unwrapped value (decltype(auto) preserves reference type)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For std::optional, assumes the value is present (call <a class="el" href="group__casting__detail.html#gace20dbc8b249b7264f6344d0e8c46333" title="Helper function to check if a value is present (not null/empty).">isPresent()</a> first) </dd>
<dd>
For pointers, returns the pointer unchanged (no dereferencing) </dd>
<dd>
Uses decltype(auto) to preserve value category and reference type</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">std::optional&lt;int&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a> = 42;</div>
<div class="line"><span class="keyword">auto</span> &amp;value = <a class="code hl_function" href="group__casting__detail.html#gac9a65a7cf30b59a490faf6bc1080f099">unwrapValue</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a>);</div>
<div class="line"><span class="comment">// value is int&amp; = 42</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> x = 10;</div>
<div class="line"><span class="keyword">auto</span> &amp;<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">same</a> = <a class="code hl_function" href="group__casting__detail.html#gac9a65a7cf30b59a490faf6bc1080f099">unwrapValue</a>(x);</div>
<div class="line"><span class="comment">// same is int&amp; = 10 (identity operation)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> *ptr = &amp;x;</div>
<div class="line"><span class="keyword">auto</span> p = <a class="code hl_function" href="group__casting__detail.html#gac9a65a7cf30b59a490faf6bc1080f099">unwrapValue</a>(ptr);</div>
<div class="line"><span class="comment">// p is int* (pointer unchanged, not dereferenced)</span></div>
<div class="ttc" id="agroup__casting__detail_html_gac9a65a7cf30b59a490faf6bc1080f099"><div class="ttname"><a href="group__casting__detail.html#gac9a65a7cf30b59a490faf6bc1080f099">corelib::detail::unwrapValue</a></div><div class="ttdeci">decltype(auto) unwrapValue(T &amp;t)</div><div class="ttdoc">Helper function to unwrap a value from its container.</div><div class="ttdef"><b>Definition</b> traits.hxx:458</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="structcorelib_1_1detail_1_1ValueIsPresent.html" title="Base template for detecting value presence and unwrapping values.">ValueIsPresent</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">the</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">underlying</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">unwrapping</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">mechanism</a> </dd>
<dd>
<a class="el" href="group__casting__detail.html#gace20dbc8b249b7264f6344d0e8c46333" title="Helper function to check if a value is present (not null/empty).">isPresent()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">if</a> a value <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">should</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">be</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">unwrapped</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga9ebd2ac000da5adfd8bd89ca7c7f5899" name="ga9ebd2ac000da5adfd8bd89ca7c7f5899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ebd2ac000da5adfd8bd89ca7c7f5899">&#9670;&#160;</a></span>IsNullable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">bool</a> corelib::detail::IsNullable = std::is_pointer_v&lt;T&gt; || std::is_constructible_v&lt;T, std::nullptr_t&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template to detect if a type can represent a null/empty state. </p>
<p>IsNullable checks whether a type T can be constructed from or compared with nullptr, indicating it has nullable semantics. This includes:</p><ul>
<li>All pointer types (T*)</li>
<li>Types constructible from std::nullptr_t (like std::unique_ptr, smart pointers)</li>
</ul>
<p>This trait is used by the casting system to determine if a type supports null-safe operations like <a class="el" href="group__casting.html#ga88d657e52bfcc3ea71532bc19b5b1575" title="Alias for dyn_cast_if_present() - null-safe dynamic cast.">dyn_cast_or_null()</a> and <a class="el" href="group__casting.html#gafefba7b24a26722051a1d828e0541f7c" title="Alias for cast_if_present() - null-safe checked cast.">cast_or_null()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check for nullable semantics</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Returns true for raw pointers and smart pointers </dd>
<dd>
Returns false for value types and references </dd>
<dd>
Used internally by <a class="el" href="structcorelib_1_1detail_1_1ValueIsPresent.html" title="Base template for detecting value presence and unwrapping values.">ValueIsPresent</a> to specialize for nullable types</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Pointer types - nullable</span></div>
<div class="line"><span class="keyword">static_assert</span>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">IsNullable&lt;int*&gt;</a>);</div>
<div class="line"><span class="keyword">static_assert</span>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">IsNullable&lt;const char*&gt;</a>);</div>
<div class="line"><span class="keyword">static_assert</span>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">IsNullable&lt;void*&gt;</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Smart pointers - nullable (constructible from nullptr)</span></div>
<div class="line"><span class="keyword">static_assert</span>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">IsNullable&lt;std::unique_ptr&lt;int&gt;</a>&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Value types - not nullable</span></div>
<div class="line"><span class="keyword">static_assert</span>(!<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">IsNullable&lt;int&gt;</a>);</div>
<div class="line"><span class="keyword">static_assert</span>(!<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">IsNullable&lt;double&gt;</a>);</div>
<div class="line"><span class="keyword">static_assert</span>(!<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">IsNullable&lt;std::string&gt;</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::optional is not considered &quot;nullable&quot; in this sense</span></div>
<div class="line"><span class="comment">// (it&#39;s not constructible from nullptr, uses std::nullopt instead)</span></div>
<div class="line"><span class="keyword">static_assert</span>(!<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">IsNullable&lt;std::optional&lt;int&gt;</a>&gt;);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="structcorelib_1_1detail_1_1ValueIsPresent.html" title="Base template for detecting value presence and unwrapping values.">ValueIsPresent</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">how</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">nullable</a> <a class="el" href="group__types.html" title="Platform-independent type aliases for integer and floating-point types.">Types Module</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">are</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">handled</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">in</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">presence</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
