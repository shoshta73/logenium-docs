<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logenium - corelib: corelib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logenium - corelib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacecorelib.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">corelib Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecorelib_1_1detail" id="r_namespacecorelib_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecorelib_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecorelib_1_1math" id="r_namespacecorelib_1_1math"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecorelib_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecorelib_1_1rtti" id="r_namespacecorelib_1_1rtti"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecorelib_1_1rtti.html">rtti</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1add__const__past__pointer.html">add_const_past_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to add const qualification past pointer indirection.  <a href="structcorelib_1_1add__const__past__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1add__lvalue__reference__if__not__pointer.html">add_lvalue_reference_if_not_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to conditionally add lvalue reference to non-pointer types.  <a href="structcorelib_1_1add__lvalue__reference__if__not__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcorelib_1_1AutoRelease.html">AutoRelease</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper for automatic resource management with custom releasers.  <a href="classcorelib_1_1AutoRelease.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1const__pointer__or__const__ref.html">const_pointer_or_const_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to create const pointer or const reference based on input type.  <a href="structcorelib_1_1const__pointer__or__const__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcorelib_1_1Defer.html">Defer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper for executing a functor at scope exit.  <a href="structcorelib_1_1Defer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcorelib_1_1is__integral__or__enum.html">is_integral_or_enum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is an integral type or enumeration.  <a href="classcorelib_1_1is__integral__or__enum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga629d6c046e9958a68edf008e635837cb" id="r_ga629d6c046e9958a68edf008e635837cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </td></tr>
<tr class="memitem:ga629d6c046e9958a68edf008e635837cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#ga629d6c046e9958a68edf008e635837cb">add_const_past_pointer_t</a> = <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="structcorelib_1_1add__const__past__pointer.html">add_const_past_pointer</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga629d6c046e9958a68edf008e635837cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type alias for <a class="el" href="structcorelib_1_1add__const__past__pointer.html" title="Type trait to add const qualification past pointer indirection.">add_const_past_pointer</a>.  <br /></td></tr>
<tr class="separator:ga629d6c046e9958a68edf008e635837cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ed950beef18ed0c7fdd962e391359e" id="r_ga53ed950beef18ed0c7fdd962e391359e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </td></tr>
<tr class="memitem:ga53ed950beef18ed0c7fdd962e391359e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#ga53ed950beef18ed0c7fdd962e391359e">add_lvalue_reference_if_not_pointer_t</a> = <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="structcorelib_1_1add__lvalue__reference__if__not__pointer.html">add_lvalue_reference_if_not_pointer</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga53ed950beef18ed0c7fdd962e391359e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type alias for <a class="el" href="structcorelib_1_1add__lvalue__reference__if__not__pointer.html" title="Type trait to conditionally add lvalue reference to non-pointer types.">add_lvalue_reference_if_not_pointer</a>.  <br /></td></tr>
<tr class="separator:ga53ed950beef18ed0c7fdd962e391359e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc0e8d84dc069c05e706d5794eda283e" id="r_gacc0e8d84dc069c05e706d5794eda283e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </td></tr>
<tr class="memitem:gacc0e8d84dc069c05e706d5794eda283e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#gacc0e8d84dc069c05e706d5794eda283e">const_pointer_or_const_ref_t</a> = <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="structcorelib_1_1const__pointer__or__const__ref.html">const_pointer_or_const_ref</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:gacc0e8d84dc069c05e706d5794eda283e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type alias for <a class="el" href="structcorelib_1_1const__pointer__or__const__ref.html" title="Type trait to create const pointer or const reference based on input type.">const_pointer_or_const_ref</a>.  <br /></td></tr>
<tr class="separator:gacc0e8d84dc069c05e706d5794eda283e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09021cdd4f388c291ea2adb4afe77396" id="r_ga09021cdd4f388c291ea2adb4afe77396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga09021cdd4f388c291ea2adb4afe77396">f32</a> = <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">float</a></td></tr>
<tr class="memdesc:ga09021cdd4f388c291ea2adb4afe77396"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit floating-point type  <br /></td></tr>
<tr class="separator:ga09021cdd4f388c291ea2adb4afe77396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1b36fbb0911fb9ba9ce9d989f23294" id="r_ga5a1b36fbb0911fb9ba9ce9d989f23294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga5a1b36fbb0911fb9ba9ce9d989f23294">f64</a> = <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">double</a></td></tr>
<tr class="memdesc:ga5a1b36fbb0911fb9ba9ce9d989f23294"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit floating-point type  <br /></td></tr>
<tr class="separator:ga5a1b36fbb0911fb9ba9ce9d989f23294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb370cf1d0ce9e457549f15290d03f1" id="r_ga3cb370cf1d0ce9e457549f15290d03f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga3cb370cf1d0ce9e457549f15290d03f1">u8</a> = std::uint8_t</td></tr>
<tr class="memdesc:ga3cb370cf1d0ce9e457549f15290d03f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit unsigned integer type  <br /></td></tr>
<tr class="separator:ga3cb370cf1d0ce9e457549f15290d03f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80cbf427faf0b7a93498e083e93390d7" id="r_ga80cbf427faf0b7a93498e083e93390d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga80cbf427faf0b7a93498e083e93390d7">u16</a> = std::uint16_t</td></tr>
<tr class="memdesc:ga80cbf427faf0b7a93498e083e93390d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit unsigned integer type  <br /></td></tr>
<tr class="separator:ga80cbf427faf0b7a93498e083e93390d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fa6dfafc74b9c43b0a0a4d58c2fefde" id="r_ga8fa6dfafc74b9c43b0a0a4d58c2fefde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga8fa6dfafc74b9c43b0a0a4d58c2fefde">u32</a> = std::uint32_t</td></tr>
<tr class="memdesc:ga8fa6dfafc74b9c43b0a0a4d58c2fefde"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integer type  <br /></td></tr>
<tr class="separator:ga8fa6dfafc74b9c43b0a0a4d58c2fefde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106117b69aacb185ea8ae85c0003fa0e" id="r_ga106117b69aacb185ea8ae85c0003fa0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga106117b69aacb185ea8ae85c0003fa0e">u64</a> = std::uint64_t</td></tr>
<tr class="memdesc:ga106117b69aacb185ea8ae85c0003fa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unsigned integer type  <br /></td></tr>
<tr class="separator:ga106117b69aacb185ea8ae85c0003fa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3f8c4ab92057ee06ac95b38047f0d3" id="r_ga3e3f8c4ab92057ee06ac95b38047f0d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga3e3f8c4ab92057ee06ac95b38047f0d3">i8</a> = std::int8_t</td></tr>
<tr class="memdesc:ga3e3f8c4ab92057ee06ac95b38047f0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed integer type  <br /></td></tr>
<tr class="separator:ga3e3f8c4ab92057ee06ac95b38047f0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b607450eb906bedef8c36e73e92ddcd" id="r_ga8b607450eb906bedef8c36e73e92ddcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga8b607450eb906bedef8c36e73e92ddcd">i16</a> = std::int16_t</td></tr>
<tr class="memdesc:ga8b607450eb906bedef8c36e73e92ddcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed integer type  <br /></td></tr>
<tr class="separator:ga8b607450eb906bedef8c36e73e92ddcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b41d8778fd45c6b8b4459dca9096ea0" id="r_ga4b41d8778fd45c6b8b4459dca9096ea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga4b41d8778fd45c6b8b4459dca9096ea0">i32</a> = std::int32_t</td></tr>
<tr class="memdesc:ga4b41d8778fd45c6b8b4459dca9096ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed integer type  <br /></td></tr>
<tr class="separator:ga4b41d8778fd45c6b8b4459dca9096ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb77597cd035992a411b4230d9368cc3" id="r_gacb77597cd035992a411b4230d9368cc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gacb77597cd035992a411b4230d9368cc3">i64</a> = std::int64_t</td></tr>
<tr class="memdesc:gacb77597cd035992a411b4230d9368cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integer type  <br /></td></tr>
<tr class="separator:gacb77597cd035992a411b4230d9368cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057c52c77c9e53aa4975469b0dee90fe" id="r_ga057c52c77c9e53aa4975469b0dee90fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga057c52c77c9e53aa4975469b0dee90fe">s8</a> = <a class="el" href="group__types.html#ga3e3f8c4ab92057ee06ac95b38047f0d3">i8</a></td></tr>
<tr class="memdesc:ga057c52c77c9e53aa4975469b0dee90fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed integer type (alias for i8)  <br /></td></tr>
<tr class="separator:ga057c52c77c9e53aa4975469b0dee90fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9cd071b5d8d0ebee78de11caffb0402" id="r_gad9cd071b5d8d0ebee78de11caffb0402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gad9cd071b5d8d0ebee78de11caffb0402">s16</a> = <a class="el" href="group__types.html#ga8b607450eb906bedef8c36e73e92ddcd">i16</a></td></tr>
<tr class="memdesc:gad9cd071b5d8d0ebee78de11caffb0402"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed integer type (alias for i16)  <br /></td></tr>
<tr class="separator:gad9cd071b5d8d0ebee78de11caffb0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ffd3ba5ae973b9d571bd72bd18f786" id="r_ga96ffd3ba5ae973b9d571bd72bd18f786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga96ffd3ba5ae973b9d571bd72bd18f786">s32</a> = <a class="el" href="group__types.html#ga4b41d8778fd45c6b8b4459dca9096ea0">i32</a></td></tr>
<tr class="memdesc:ga96ffd3ba5ae973b9d571bd72bd18f786"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed integer type (alias for i32)  <br /></td></tr>
<tr class="separator:ga96ffd3ba5ae973b9d571bd72bd18f786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcbeb95ccae7fa06e21b89afad8b54a7" id="r_gabcbeb95ccae7fa06e21b89afad8b54a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gabcbeb95ccae7fa06e21b89afad8b54a7">s64</a> = <a class="el" href="group__types.html#gacb77597cd035992a411b4230d9368cc3">i64</a></td></tr>
<tr class="memdesc:gabcbeb95ccae7fa06e21b89afad8b54a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integer type (alias for i64)  <br /></td></tr>
<tr class="separator:gabcbeb95ccae7fa06e21b89afad8b54a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac24e683d07e76a05c5491d91d32f7557" id="r_gac24e683d07e76a05c5491d91d32f7557"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </td></tr>
<tr class="memitem:gac24e683d07e76a05c5491d91d32f7557"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gac24e683d07e76a05c5491d91d32f7557">type_name</a> ()</td></tr>
<tr class="memdesc:gac24e683d07e76a05c5491d91d32f7557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the type name of a template parameter at compile time.  <br /></td></tr>
<tr class="separator:gac24e683d07e76a05c5491d91d32f7557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a32d577d23e32368394673b286ada8" id="r_ga43a32d577d23e32368394673b286ada8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </td></tr>
<tr class="memitem:ga43a32d577d23e32368394673b286ada8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga43a32d577d23e32368394673b286ada8">type_name</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:ga43a32d577d23e32368394673b286ada8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the type name from a value at compile time.  <br /></td></tr>
<tr class="separator:ga43a32d577d23e32368394673b286ada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0612fde000a014ae055fdc0ef1c5f06a" id="r_ga0612fde000a014ae055fdc0ef1c5f06a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </td></tr>
<tr class="memitem:ga0612fde000a014ae055fdc0ef1c5f06a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a">cast</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">const</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ga0612fde000a014ae055fdc0ef1c5f06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked cast with assertion on type mismatch.  <br /></td></tr>
<tr class="separator:ga0612fde000a014ae055fdc0ef1c5f06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07f29433e7eb990ac7ed3b1ceaa7dad" id="r_ac07f29433e7eb990ac7ed3b1ceaa7dad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </td></tr>
<tr class="memitem:ac07f29433e7eb990ac7ed3b1ceaa7dad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#ac07f29433e7eb990ac7ed3b1ceaa7dad">cast</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ac07f29433e7eb990ac7ed3b1ceaa7dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked cast with assertion on type mismatch.    <br /></td></tr>
<tr class="separator:ac07f29433e7eb990ac7ed3b1ceaa7dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bacf7564f9a4ecea5eb6e3dbc8fd666" id="r_a9bacf7564f9a4ecea5eb6e3dbc8fd666"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </td></tr>
<tr class="memitem:a9bacf7564f9a4ecea5eb6e3dbc8fd666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a9bacf7564f9a4ecea5eb6e3dbc8fd666">cast</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> *<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a9bacf7564f9a4ecea5eb6e3dbc8fd666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked cast with assertion on type mismatch.    <br /></td></tr>
<tr class="separator:a9bacf7564f9a4ecea5eb6e3dbc8fd666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34745d6a4ac4a80b908cd8d4a5a1b09" id="r_ab34745d6a4ac4a80b908cd8d4a5a1b09"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </td></tr>
<tr class="memitem:ab34745d6a4ac4a80b908cd8d4a5a1b09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#ab34745d6a4ac4a80b908cd8d4a5a1b09">cast</a> (std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; &amp;&amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ab34745d6a4ac4a80b908cd8d4a5a1b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked cast with assertion on type mismatch.    <br /></td></tr>
<tr class="separator:ab34745d6a4ac4a80b908cd8d4a5a1b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cf1ac44d2a0a7830f22480b836e1801" id="r_ga7cf1ac44d2a0a7830f22480b836e1801"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:ga7cf1ac44d2a0a7830f22480b836e1801"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801">cast_if_present</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">const</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ga7cf1ac44d2a0a7830f22480b836e1801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe checked cast with assertion on type mismatch.  <br /></td></tr>
<tr class="separator:ga7cf1ac44d2a0a7830f22480b836e1801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8d1941223239a6b7fe4f96664eb99f" id="r_a7c8d1941223239a6b7fe4f96664eb99f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:a7c8d1941223239a6b7fe4f96664eb99f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a7c8d1941223239a6b7fe4f96664eb99f">cast_if_present</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a7c8d1941223239a6b7fe4f96664eb99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe checked cast with assertion on type mismatch.    <br /></td></tr>
<tr class="separator:a7c8d1941223239a6b7fe4f96664eb99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8178a9ace3f4fd4e65e8ecb065e86c" id="r_a2d8178a9ace3f4fd4e65e8ecb065e86c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:a2d8178a9ace3f4fd4e65e8ecb065e86c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a2d8178a9ace3f4fd4e65e8ecb065e86c">cast_if_present</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> *<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a2d8178a9ace3f4fd4e65e8ecb065e86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe checked cast with assertion on type mismatch.    <br /></td></tr>
<tr class="separator:a2d8178a9ace3f4fd4e65e8ecb065e86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ee56958fb3efe03056bd4185d3f231" id="r_a00ee56958fb3efe03056bd4185d3f231"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:a00ee56958fb3efe03056bd4185d3f231"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a00ee56958fb3efe03056bd4185d3f231">cast_if_present</a> (std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;&amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a00ee56958fb3efe03056bd4185d3f231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe checked cast with assertion on type mismatch.    <br /></td></tr>
<tr class="separator:a00ee56958fb3efe03056bd4185d3f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafefba7b24a26722051a1d828e0541f7c" id="r_gafefba7b24a26722051a1d828e0541f7c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:gafefba7b24a26722051a1d828e0541f7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#gafefba7b24a26722051a1d828e0541f7c">cast_or_null</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">const</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:gafefba7b24a26722051a1d828e0541f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> - null-safe checked cast.  <br /></td></tr>
<tr class="separator:gafefba7b24a26722051a1d828e0541f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6803a28d82c6018ac8eea72d865da48" id="r_ae6803a28d82c6018ac8eea72d865da48"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:ae6803a28d82c6018ac8eea72d865da48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#ae6803a28d82c6018ac8eea72d865da48">cast_or_null</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ae6803a28d82c6018ac8eea72d865da48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> - null-safe checked cast.    <br /></td></tr>
<tr class="separator:ae6803a28d82c6018ac8eea72d865da48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185551f91b6505cdb17df6403766a502" id="r_a185551f91b6505cdb17df6403766a502"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:a185551f91b6505cdb17df6403766a502"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a185551f91b6505cdb17df6403766a502">cast_or_null</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> *<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a185551f91b6505cdb17df6403766a502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> - null-safe checked cast.    <br /></td></tr>
<tr class="separator:a185551f91b6505cdb17df6403766a502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0ce038c14cb139d6bcd2901f0d9ab0" id="r_aea0ce038c14cb139d6bcd2901f0d9ab0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:aea0ce038c14cb139d6bcd2901f0d9ab0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#aea0ce038c14cb139d6bcd2901f0d9ab0">cast_or_null</a> (std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;&amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:aea0ce038c14cb139d6bcd2901f0d9ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> - null-safe checked cast.    <br /></td></tr>
<tr class="separator:aea0ce038c14cb139d6bcd2901f0d9ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae484b007072d62449ecda4be20b42179" id="r_gae484b007072d62449ecda4be20b42179"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </td></tr>
<tr class="memitem:gae484b007072d62449ecda4be20b42179"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179">dyn_cast</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">const</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:gae484b007072d62449ecda4be20b42179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast that returns nullptr on type mismatch.  <br /></td></tr>
<tr class="separator:gae484b007072d62449ecda4be20b42179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750e97235651993722aacfb4ae28c316" id="r_a750e97235651993722aacfb4ae28c316"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </td></tr>
<tr class="memitem:a750e97235651993722aacfb4ae28c316"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a750e97235651993722aacfb4ae28c316">dyn_cast</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a750e97235651993722aacfb4ae28c316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast that returns nullptr on type mismatch.    <br /></td></tr>
<tr class="separator:a750e97235651993722aacfb4ae28c316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b832881676b821a3a725097329d4fa" id="r_a64b832881676b821a3a725097329d4fa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </td></tr>
<tr class="memitem:a64b832881676b821a3a725097329d4fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a64b832881676b821a3a725097329d4fa">dyn_cast</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> *<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a64b832881676b821a3a725097329d4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast that returns nullptr on type mismatch.    <br /></td></tr>
<tr class="separator:a64b832881676b821a3a725097329d4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade9c253cc43f65206215d40cabd1b02" id="r_aade9c253cc43f65206215d40cabd1b02"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </td></tr>
<tr class="memitem:aade9c253cc43f65206215d40cabd1b02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#aade9c253cc43f65206215d40cabd1b02">dyn_cast</a> (std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:aade9c253cc43f65206215d40cabd1b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast that returns nullptr on type mismatch.    <br /></td></tr>
<tr class="separator:aade9c253cc43f65206215d40cabd1b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b32b071c53b4f77dbbf3a4300db5b5c" id="r_ga1b32b071c53b4f77dbbf3a4300db5b5c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:ga1b32b071c53b4f77dbbf3a4300db5b5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c">dyn_cast_if_present</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">const</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ga1b32b071c53b4f77dbbf3a4300db5b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe dynamic cast with presence checking.  <br /></td></tr>
<tr class="separator:ga1b32b071c53b4f77dbbf3a4300db5b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a3460f3a07f4029776ed8503473b21" id="r_a81a3460f3a07f4029776ed8503473b21"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:a81a3460f3a07f4029776ed8503473b21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a81a3460f3a07f4029776ed8503473b21">dyn_cast_if_present</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a81a3460f3a07f4029776ed8503473b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe dynamic cast with presence checking.    <br /></td></tr>
<tr class="separator:a81a3460f3a07f4029776ed8503473b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca5b5fc19f14cf3d6fd9ab2eb68ab3d" id="r_a2ca5b5fc19f14cf3d6fd9ab2eb68ab3d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:a2ca5b5fc19f14cf3d6fd9ab2eb68ab3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a2ca5b5fc19f14cf3d6fd9ab2eb68ab3d">dyn_cast_if_present</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> *<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a2ca5b5fc19f14cf3d6fd9ab2eb68ab3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe dynamic cast with presence checking.    <br /></td></tr>
<tr class="separator:a2ca5b5fc19f14cf3d6fd9ab2eb68ab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d657e52bfcc3ea71532bc19b5b1575" id="r_ga88d657e52bfcc3ea71532bc19b5b1575"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:ga88d657e52bfcc3ea71532bc19b5b1575"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga88d657e52bfcc3ea71532bc19b5b1575">dyn_cast_or_null</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">const</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ga88d657e52bfcc3ea71532bc19b5b1575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> - null-safe dynamic cast.  <br /></td></tr>
<tr class="separator:ga88d657e52bfcc3ea71532bc19b5b1575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3279a5fff48ff7c5c5a2861a0676a1c" id="r_ad3279a5fff48ff7c5c5a2861a0676a1c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:ad3279a5fff48ff7c5c5a2861a0676a1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#ad3279a5fff48ff7c5c5a2861a0676a1c">dyn_cast_or_null</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ad3279a5fff48ff7c5c5a2861a0676a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> - null-safe dynamic cast.    <br /></td></tr>
<tr class="separator:ad3279a5fff48ff7c5c5a2861a0676a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616ff1074888b3ca6933dc4b8eff8a2a" id="r_a616ff1074888b3ca6933dc4b8eff8a2a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:a616ff1074888b3ca6933dc4b8eff8a2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a616ff1074888b3ca6933dc4b8eff8a2a">dyn_cast_or_null</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> *<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a616ff1074888b3ca6933dc4b8eff8a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> - null-safe dynamic cast.    <br /></td></tr>
<tr class="separator:a616ff1074888b3ca6933dc4b8eff8a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6434dfe4978d4921d20eecf9959c36" id="r_ga1b6434dfe4978d4921d20eecf9959c36"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:ga1b6434dfe4978d4921d20eecf9959c36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcorelib_1_1detail_1_1CastInfo.html">detail::CastInfo</a>&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a>, std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &gt;::CastResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga1b6434dfe4978d4921d20eecf9959c36">unique_dyn_cast</a> (std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ga1b6434dfe4978d4921d20eecf9959c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized dynamic cast for std::unique_ptr with ownership transfer.  <br /></td></tr>
<tr class="separator:ga1b6434dfe4978d4921d20eecf9959c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4a4863f86ade1c8f9e3b7cf5a5f5f1" id="r_aac4a4863f86ade1c8f9e3b7cf5a5f5f1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:aac4a4863f86ade1c8f9e3b7cf5a5f5f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#aac4a4863f86ade1c8f9e3b7cf5a5f5f1">unique_dyn_cast</a> (std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;&amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:aac4a4863f86ade1c8f9e3b7cf5a5f5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized dynamic cast for std::unique_ptr with ownership transfer.    <br /></td></tr>
<tr class="separator:aac4a4863f86ade1c8f9e3b7cf5a5f5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90e00c9795d47bfe31f4bf1a1a3aac6f" id="r_ga90e00c9795d47bfe31f4bf1a1a3aac6f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:ga90e00c9795d47bfe31f4bf1a1a3aac6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcorelib_1_1detail_1_1CastInfo.html">detail::CastInfo</a>&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a>, std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &gt;::CastResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga90e00c9795d47bfe31f4bf1a1a3aac6f">unique_dyn_cast_or_null</a> (std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ga90e00c9795d47bfe31f4bf1a1a3aac6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe unique_ptr dynamic cast with ownership transfer.  <br /></td></tr>
<tr class="separator:ga90e00c9795d47bfe31f4bf1a1a3aac6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba87a9d9f2ec01ce96042af88df2918" id="r_a6ba87a9d9f2ec01ce96042af88df2918"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:a6ba87a9d9f2ec01ce96042af88df2918"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecorelib.html#a6ba87a9d9f2ec01ce96042af88df2918">unique_dyn_cast_or_null</a> (std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;&amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:a6ba87a9d9f2ec01ce96042af88df2918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe unique_ptr dynamic cast with ownership transfer.    <br /></td></tr>
<tr class="separator:a6ba87a9d9f2ec01ce96042af88df2918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d42fef17770f4f775ad655ab85e2b8" id="r_ga21d42fef17770f4f775ad655ab85e2b8"><td class="memTemplParams" colspan="2">template&lt;typename... To, typename From &gt; </td></tr>
<tr class="memitem:ga21d42fef17770f4f775ad655ab85e2b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">isa</a> (const From &amp;Val)</td></tr>
<tr class="memdesc:ga21d42fef17770f4f775ad655ab85e2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a value is an instance of any of the specified types.  <br /></td></tr>
<tr class="separator:ga21d42fef17770f4f775ad655ab85e2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga460d2e78e8bfb779edc96b052b81ec33" id="r_ga460d2e78e8bfb779edc96b052b81ec33"><td class="memTemplParams" colspan="2">template&lt;typename... X, <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </td></tr>
<tr class="memitem:ga460d2e78e8bfb779edc96b052b81ec33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga460d2e78e8bfb779edc96b052b81ec33">isa_and_present</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">const</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Val</a>)</td></tr>
<tr class="memdesc:ga460d2e78e8bfb779edc96b052b81ec33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe type checking with presence validation.  <br /></td></tr>
<tr class="separator:ga460d2e78e8bfb779edc96b052b81ec33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga31dd71eb85e95e4aaed0cdadb56f2658" id="r_ga31dd71eb85e95e4aaed0cdadb56f2658"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga31dd71eb85e95e4aaed0cdadb56f2658"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="structcorelib_1_1detail_1_1IsaCheckPredicate.html">detail::IsaCheckPredicate</a>&lt; Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga31dd71eb85e95e4aaed0cdadb56f2658">IsaPred</a> {}</td></tr>
<tr class="memdesc:ga31dd71eb85e95e4aaed0cdadb56f2658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate functor for variadic type checking with algorithms.  <br /></td></tr>
<tr class="separator:ga31dd71eb85e95e4aaed0cdadb56f2658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1de171e7b84de7868a572f7b2d057a" id="r_gafe1de171e7b84de7868a572f7b2d057a"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gafe1de171e7b84de7868a572f7b2d057a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="structcorelib_1_1detail_1_1IsaAndPresentCheckPredicate.html">detail::IsaAndPresentCheckPredicate</a>&lt; Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#gafe1de171e7b84de7868a572f7b2d057a">IsaAndPresentPred</a> {}</td></tr>
<tr class="memdesc:gafe1de171e7b84de7868a572f7b2d057a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-safe predicate functor for type checking with algorithms.  <br /></td></tr>
<tr class="separator:gafe1de171e7b84de7868a572f7b2d057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga400dd3e5fa40fcc6a9bb570ae9234d5e" id="r_ga400dd3e5fa40fcc6a9bb570ae9234d5e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt; </td></tr>
<tr class="memitem:ga400dd3e5fa40fcc6a9bb570ae9234d5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="structcorelib_1_1detail_1_1StaticCastFunc.html">detail::StaticCastFunc</a>&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga400dd3e5fa40fcc6a9bb570ae9234d5e">StaticCastTo</a> {}</td></tr>
<tr class="memdesc:ga400dd3e5fa40fcc6a9bb570ae9234d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for static_cast operations with algorithms.  <br /></td></tr>
<tr class="separator:ga400dd3e5fa40fcc6a9bb570ae9234d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5091856f869fd8136f52b01ebfe7465d" id="r_ga5091856f869fd8136f52b01ebfe7465d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt; </td></tr>
<tr class="memitem:ga5091856f869fd8136f52b01ebfe7465d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="structcorelib_1_1detail_1_1CastFunc.html">detail::CastFunc</a>&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga5091856f869fd8136f52b01ebfe7465d">CastTo</a> {}</td></tr>
<tr class="memdesc:ga5091856f869fd8136f52b01ebfe7465d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for checked cast operations with algorithms.  <br /></td></tr>
<tr class="separator:ga5091856f869fd8136f52b01ebfe7465d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b138258f041f49a8e1068decd0d482" id="r_gae9b138258f041f49a8e1068decd0d482"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt; </td></tr>
<tr class="memitem:gae9b138258f041f49a8e1068decd0d482"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="structcorelib_1_1detail_1_1CastIfPresentFunc.html">detail::CastIfPresentFunc</a>&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#gae9b138258f041f49a8e1068decd0d482">CastIfPresentTo</a> {}</td></tr>
<tr class="memdesc:gae9b138258f041f49a8e1068decd0d482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for null-safe checked cast operations with algorithms.  <br /></td></tr>
<tr class="separator:gae9b138258f041f49a8e1068decd0d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38b7141d43c63bbf98dba5117817c63" id="r_gae38b7141d43c63bbf98dba5117817c63"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt; </td></tr>
<tr class="memitem:gae38b7141d43c63bbf98dba5117817c63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="structcorelib_1_1detail_1_1DynCastIfPresentFunc.html">detail::DynCastIfPresentFunc</a>&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#gae38b7141d43c63bbf98dba5117817c63">DynCastIfPresentTo</a> {}</td></tr>
<tr class="memdesc:gae38b7141d43c63bbf98dba5117817c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for null-safe dynamic cast operations with algorithms.  <br /></td></tr>
<tr class="separator:gae38b7141d43c63bbf98dba5117817c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1f69d74a19cd9b40a2cca4e98b1651" id="r_ga8f1f69d74a19cd9b40a2cca4e98b1651"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt; </td></tr>
<tr class="memitem:ga8f1f69d74a19cd9b40a2cca4e98b1651"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="structcorelib_1_1detail_1_1DynCastFunc.html">detail::DynCastFunc</a>&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting.html#ga8f1f69d74a19cd9b40a2cca4e98b1651">DynCastTo</a> {}</td></tr>
<tr class="memdesc:ga8f1f69d74a19cd9b40a2cca4e98b1651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for dynamic cast operations with algorithms.  <br /></td></tr>
<tr class="separator:ga8f1f69d74a19cd9b40a2cca4e98b1651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f4b09528fa44c67100284479fc4cf5" id="r_ga66f4b09528fa44c67100284479fc4cf5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> T &gt; </td></tr>
<tr class="memitem:ga66f4b09528fa44c67100284479fc4cf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#ga66f4b09528fa44c67100284479fc4cf5">is_integral_or_enum_v</a> = <a class="el" href="classcorelib_1_1is__integral__or__enum.html">is_integral_or_enum</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga66f4b09528fa44c67100284479fc4cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template for <a class="el" href="classcorelib_1_1is__integral__or__enum.html" title="Type trait to check if a type is an integral type or enumeration.">is_integral_or_enum</a>.  <br /></td></tr>
<tr class="separator:ga66f4b09528fa44c67100284479fc4cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3004726834329a18dc9cceb8412a757" id="r_gaa3004726834329a18dc9cceb8412a757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga09021cdd4f388c291ea2adb4afe77396">f32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gaa3004726834329a18dc9cceb8412a757">f32_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga09021cdd4f388c291ea2adb4afe77396">f32</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:gaa3004726834329a18dc9cceb8412a757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum positive normalized value for f32 type.  <br /></td></tr>
<tr class="separator:gaa3004726834329a18dc9cceb8412a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5938dccee7a77e6fc1b9b603a05f53f" id="r_gac5938dccee7a77e6fc1b9b603a05f53f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga09021cdd4f388c291ea2adb4afe77396">f32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gac5938dccee7a77e6fc1b9b603a05f53f">f32_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga09021cdd4f388c291ea2adb4afe77396">f32</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:gac5938dccee7a77e6fc1b9b603a05f53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for f32 type.  <br /></td></tr>
<tr class="separator:gac5938dccee7a77e6fc1b9b603a05f53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb36d3a979be4c1080352be820a9cca3" id="r_gacb36d3a979be4c1080352be820a9cca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga5a1b36fbb0911fb9ba9ce9d989f23294">f64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gacb36d3a979be4c1080352be820a9cca3">f64_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga5a1b36fbb0911fb9ba9ce9d989f23294">f64</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:gacb36d3a979be4c1080352be820a9cca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum positive normalized value for f64 type.  <br /></td></tr>
<tr class="separator:gacb36d3a979be4c1080352be820a9cca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f2b705472c92cd91b6a9c5d5d8197b1" id="r_ga2f2b705472c92cd91b6a9c5d5d8197b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga5a1b36fbb0911fb9ba9ce9d989f23294">f64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga2f2b705472c92cd91b6a9c5d5d8197b1">f64_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga5a1b36fbb0911fb9ba9ce9d989f23294">f64</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:ga2f2b705472c92cd91b6a9c5d5d8197b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for f64 type.  <br /></td></tr>
<tr class="separator:ga2f2b705472c92cd91b6a9c5d5d8197b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd6b2760d2643b5e948789d656433e6" id="r_ga0bd6b2760d2643b5e948789d656433e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga3cb370cf1d0ce9e457549f15290d03f1">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga0bd6b2760d2643b5e948789d656433e6">u8_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga3cb370cf1d0ce9e457549f15290d03f1">u8</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:ga0bd6b2760d2643b5e948789d656433e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for u8 type.  <br /></td></tr>
<tr class="separator:ga0bd6b2760d2643b5e948789d656433e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cec4651d43334e278b59d9f5ba30ef5" id="r_ga7cec4651d43334e278b59d9f5ba30ef5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga3cb370cf1d0ce9e457549f15290d03f1">u8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga7cec4651d43334e278b59d9f5ba30ef5">u8_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga3cb370cf1d0ce9e457549f15290d03f1">u8</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:ga7cec4651d43334e278b59d9f5ba30ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for u8 type.  <br /></td></tr>
<tr class="separator:ga7cec4651d43334e278b59d9f5ba30ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb29d9cf86f0a2702372fcb1887d155" id="r_gabeb29d9cf86f0a2702372fcb1887d155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga80cbf427faf0b7a93498e083e93390d7">u16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gabeb29d9cf86f0a2702372fcb1887d155">u16_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga80cbf427faf0b7a93498e083e93390d7">u16</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:gabeb29d9cf86f0a2702372fcb1887d155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for u16 type.  <br /></td></tr>
<tr class="separator:gabeb29d9cf86f0a2702372fcb1887d155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35af9bce9bcc4b1b7a3c504f72881f80" id="r_ga35af9bce9bcc4b1b7a3c504f72881f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga80cbf427faf0b7a93498e083e93390d7">u16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga35af9bce9bcc4b1b7a3c504f72881f80">u16_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga80cbf427faf0b7a93498e083e93390d7">u16</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:ga35af9bce9bcc4b1b7a3c504f72881f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for u16 type.  <br /></td></tr>
<tr class="separator:ga35af9bce9bcc4b1b7a3c504f72881f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dcba28fed399aea2e5b2f2c15d1d255" id="r_ga8dcba28fed399aea2e5b2f2c15d1d255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga8fa6dfafc74b9c43b0a0a4d58c2fefde">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga8dcba28fed399aea2e5b2f2c15d1d255">u32_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga8fa6dfafc74b9c43b0a0a4d58c2fefde">u32</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:ga8dcba28fed399aea2e5b2f2c15d1d255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for u32 type.  <br /></td></tr>
<tr class="separator:ga8dcba28fed399aea2e5b2f2c15d1d255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf743aa7237f9798789c5d692ac53f4f0" id="r_gaf743aa7237f9798789c5d692ac53f4f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga8fa6dfafc74b9c43b0a0a4d58c2fefde">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gaf743aa7237f9798789c5d692ac53f4f0">u32_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga8fa6dfafc74b9c43b0a0a4d58c2fefde">u32</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:gaf743aa7237f9798789c5d692ac53f4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for u32 type.  <br /></td></tr>
<tr class="separator:gaf743aa7237f9798789c5d692ac53f4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0164e2cd0dfff4bf4ba1e438c9c2a4a2" id="r_ga0164e2cd0dfff4bf4ba1e438c9c2a4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga106117b69aacb185ea8ae85c0003fa0e">u64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga0164e2cd0dfff4bf4ba1e438c9c2a4a2">u64_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga106117b69aacb185ea8ae85c0003fa0e">u64</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:ga0164e2cd0dfff4bf4ba1e438c9c2a4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for u64 type.  <br /></td></tr>
<tr class="separator:ga0164e2cd0dfff4bf4ba1e438c9c2a4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c5e70ab7fb485ee3392e238876dd72" id="r_ga69c5e70ab7fb485ee3392e238876dd72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga106117b69aacb185ea8ae85c0003fa0e">u64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga69c5e70ab7fb485ee3392e238876dd72">u64_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga106117b69aacb185ea8ae85c0003fa0e">u64</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:ga69c5e70ab7fb485ee3392e238876dd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for u64 type.  <br /></td></tr>
<tr class="separator:ga69c5e70ab7fb485ee3392e238876dd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b75d9d0e410e1f0224d3f303bcd4db" id="r_ga95b75d9d0e410e1f0224d3f303bcd4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga3e3f8c4ab92057ee06ac95b38047f0d3">i8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga95b75d9d0e410e1f0224d3f303bcd4db">i8_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga3e3f8c4ab92057ee06ac95b38047f0d3">i8</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:ga95b75d9d0e410e1f0224d3f303bcd4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for i8 type.  <br /></td></tr>
<tr class="separator:ga95b75d9d0e410e1f0224d3f303bcd4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7e202b3467b097bf56c5999fefbcdb2" id="r_gaa7e202b3467b097bf56c5999fefbcdb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga3e3f8c4ab92057ee06ac95b38047f0d3">i8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gaa7e202b3467b097bf56c5999fefbcdb2">i8_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga3e3f8c4ab92057ee06ac95b38047f0d3">i8</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:gaa7e202b3467b097bf56c5999fefbcdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for i8 type.  <br /></td></tr>
<tr class="separator:gaa7e202b3467b097bf56c5999fefbcdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ee553601be6ad2eb28c4f3fc51a114" id="r_gab7ee553601be6ad2eb28c4f3fc51a114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga8b607450eb906bedef8c36e73e92ddcd">i16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gab7ee553601be6ad2eb28c4f3fc51a114">i16_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga8b607450eb906bedef8c36e73e92ddcd">i16</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:gab7ee553601be6ad2eb28c4f3fc51a114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for i16 type.  <br /></td></tr>
<tr class="separator:gab7ee553601be6ad2eb28c4f3fc51a114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78250d373e284906bba4b2c4024a5600" id="r_ga78250d373e284906bba4b2c4024a5600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga8b607450eb906bedef8c36e73e92ddcd">i16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga78250d373e284906bba4b2c4024a5600">i16_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga8b607450eb906bedef8c36e73e92ddcd">i16</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:ga78250d373e284906bba4b2c4024a5600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for i16 type.  <br /></td></tr>
<tr class="separator:ga78250d373e284906bba4b2c4024a5600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f08d5f63c9b0b3dffbb923029669160" id="r_ga4f08d5f63c9b0b3dffbb923029669160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga4b41d8778fd45c6b8b4459dca9096ea0">i32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga4f08d5f63c9b0b3dffbb923029669160">i32_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga4b41d8778fd45c6b8b4459dca9096ea0">i32</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:ga4f08d5f63c9b0b3dffbb923029669160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for i32 type.  <br /></td></tr>
<tr class="separator:ga4f08d5f63c9b0b3dffbb923029669160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6fe8d9da5efdef4e388a11a7fb667ae" id="r_gaa6fe8d9da5efdef4e388a11a7fb667ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga4b41d8778fd45c6b8b4459dca9096ea0">i32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gaa6fe8d9da5efdef4e388a11a7fb667ae">i32_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#ga4b41d8778fd45c6b8b4459dca9096ea0">i32</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:gaa6fe8d9da5efdef4e388a11a7fb667ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for i32 type.  <br /></td></tr>
<tr class="separator:gaa6fe8d9da5efdef4e388a11a7fb667ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20bb4e27c5f0db43e98350b1b4c8fc5f" id="r_ga20bb4e27c5f0db43e98350b1b4c8fc5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#gacb77597cd035992a411b4230d9368cc3">i64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga20bb4e27c5f0db43e98350b1b4c8fc5f">i64_min</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#gacb77597cd035992a411b4230d9368cc3">i64</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::min</a>()</td></tr>
<tr class="memdesc:ga20bb4e27c5f0db43e98350b1b4c8fc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for i64 type.  <br /></td></tr>
<tr class="separator:ga20bb4e27c5f0db43e98350b1b4c8fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8cc36d83c9857e685bf9821fc51b846" id="r_gac8cc36d83c9857e685bf9821fc51b846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#gacb77597cd035992a411b4230d9368cc3">i64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gac8cc36d83c9857e685bf9821fc51b846">i64_max</a> = std::numeric_limits&lt;<a class="el" href="group__types.html#gacb77597cd035992a411b4230d9368cc3">i64</a>&gt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">::max</a>()</td></tr>
<tr class="memdesc:gac8cc36d83c9857e685bf9821fc51b846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for i64 type.  <br /></td></tr>
<tr class="separator:gac8cc36d83c9857e685bf9821fc51b846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391f4fc36210cf548340e46a37c9e0e7" id="r_ga391f4fc36210cf548340e46a37c9e0e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga057c52c77c9e53aa4975469b0dee90fe">s8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga391f4fc36210cf548340e46a37c9e0e7">s8_min</a> = <a class="el" href="group__types.html#ga95b75d9d0e410e1f0224d3f303bcd4db">i8_min</a></td></tr>
<tr class="memdesc:ga391f4fc36210cf548340e46a37c9e0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for s8 type.  <br /></td></tr>
<tr class="separator:ga391f4fc36210cf548340e46a37c9e0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2487fe1fdab5ddc0ddcf53dcb2a62ad2" id="r_ga2487fe1fdab5ddc0ddcf53dcb2a62ad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga057c52c77c9e53aa4975469b0dee90fe">s8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga2487fe1fdab5ddc0ddcf53dcb2a62ad2">s8_max</a> = <a class="el" href="group__types.html#gaa7e202b3467b097bf56c5999fefbcdb2">i8_max</a></td></tr>
<tr class="memdesc:ga2487fe1fdab5ddc0ddcf53dcb2a62ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for s8 type.  <br /></td></tr>
<tr class="separator:ga2487fe1fdab5ddc0ddcf53dcb2a62ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f832175623bb1653120c627c2b8042" id="r_ga58f832175623bb1653120c627c2b8042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#gad9cd071b5d8d0ebee78de11caffb0402">s16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga58f832175623bb1653120c627c2b8042">s16_min</a> = <a class="el" href="group__types.html#gab7ee553601be6ad2eb28c4f3fc51a114">i16_min</a></td></tr>
<tr class="memdesc:ga58f832175623bb1653120c627c2b8042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for s16 type.  <br /></td></tr>
<tr class="separator:ga58f832175623bb1653120c627c2b8042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1977683b5ae97fcbdb34cb9e2cc6895b" id="r_ga1977683b5ae97fcbdb34cb9e2cc6895b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#gad9cd071b5d8d0ebee78de11caffb0402">s16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga1977683b5ae97fcbdb34cb9e2cc6895b">s16_max</a> = <a class="el" href="group__types.html#ga78250d373e284906bba4b2c4024a5600">i16_max</a></td></tr>
<tr class="memdesc:ga1977683b5ae97fcbdb34cb9e2cc6895b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for s16 type.  <br /></td></tr>
<tr class="separator:ga1977683b5ae97fcbdb34cb9e2cc6895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a8261eec8c0513e867f26f912e16d7" id="r_ga34a8261eec8c0513e867f26f912e16d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga96ffd3ba5ae973b9d571bd72bd18f786">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga34a8261eec8c0513e867f26f912e16d7">s32_min</a> = <a class="el" href="group__types.html#ga4f08d5f63c9b0b3dffbb923029669160">i32_min</a></td></tr>
<tr class="memdesc:ga34a8261eec8c0513e867f26f912e16d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for s32 type.  <br /></td></tr>
<tr class="separator:ga34a8261eec8c0513e867f26f912e16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad412651a6bb812d03d9aa08f31f0f607" id="r_gad412651a6bb812d03d9aa08f31f0f607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#ga96ffd3ba5ae973b9d571bd72bd18f786">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gad412651a6bb812d03d9aa08f31f0f607">s32_max</a> = <a class="el" href="group__types.html#gaa6fe8d9da5efdef4e388a11a7fb667ae">i32_max</a></td></tr>
<tr class="memdesc:gad412651a6bb812d03d9aa08f31f0f607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for s32 type.  <br /></td></tr>
<tr class="separator:gad412651a6bb812d03d9aa08f31f0f607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa681924bc1ce78885f880a1dbc72c932" id="r_gaa681924bc1ce78885f880a1dbc72c932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#gabcbeb95ccae7fa06e21b89afad8b54a7">s64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#gaa681924bc1ce78885f880a1dbc72c932">s64_min</a> = <a class="el" href="group__types.html#ga20bb4e27c5f0db43e98350b1b4c8fc5f">i64_min</a></td></tr>
<tr class="memdesc:gaa681924bc1ce78885f880a1dbc72c932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value for s64 type.  <br /></td></tr>
<tr class="separator:gaa681924bc1ce78885f880a1dbc72c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga498331f2339353586a8e203392c2b572" id="r_ga498331f2339353586a8e203392c2b572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">constexpr</a> <a class="el" href="group__types.html#gabcbeb95ccae7fa06e21b89afad8b54a7">s64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__types.html#ga498331f2339353586a8e203392c2b572">s64_max</a> = <a class="el" href="group__types.html#gac8cc36d83c9857e685bf9821fc51b846">i64_max</a></td></tr>
<tr class="memdesc:ga498331f2339353586a8e203392c2b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for s64 type.  <br /></td></tr>
<tr class="separator:ga498331f2339353586a8e203392c2b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac07f29433e7eb990ac7ed3b1ceaa7dad" name="ac07f29433e7eb990ac7ed3b1ceaa7dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07f29433e7eb990ac7ed3b1ceaa7dad">&#9670;&#160;</a></span>cast() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>) corelib::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked cast with assertion on type mismatch.   </p>
<p><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a> performs a type-safe downcast with runtime type checking and assertion. It first checks if the cast is valid using isa&lt;To&gt;(Val), then performs the cast. If the type check fails, it asserts in debug builds.</p>
<p>Supported types:</p><ul>
<li>References (const and non-const)</li>
<li>Pointers</li>
<li>std::unique_ptr (transfers ownership)</li>
</ul>
<p>Return type preserves const-correctness and reference/pointer semantics:</p><ul>
<li>const From&amp;  const To&amp;</li>
<li>From&amp;  To&amp;</li>
<li>From*  To*</li>
<li>unique_ptr&lt;From&gt;  unique_ptr&lt;To&gt;</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The target type </td></tr>
    <tr><td class="paramname">From</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value (type depends on input)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Asserts if Val is not an instance of To (debug::Assert) </dd>
<dd>
For pointers/unique_ptr, asserts Val is not null </dd>
<dd>
For unique_ptr, ownership is transferred (Val becomes empty) </dd>
<dd>
Uses decltype(auto) to preserve value categories</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">getDerived</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast pointer (asserts if not Derived)</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast reference</span></div>
<div class="line">Base &amp;<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">ref</a> = ...;</div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> &amp;<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dref</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">ref</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast unique_ptr (transfers ownership)</span></div>
<div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a> = ...;</div>
<div class="line">std::unique_ptr&lt;Derived&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(std::move(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a>));</div>
<div class="line"><span class="comment">// uptr is now empty</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Preserves const</span></div>
<div class="line"><span class="keyword">const</span> Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cbase</a> = ...;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cderived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cbase</a>);</div>
<div class="ttc" id="agroup__casting_html_ga21d42fef17770f4f775ad655ab85e2b8"><div class="ttname"><a href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">corelib::isa</a></div><div class="ttdeci">bool isa(const From &amp;Val)</div><div class="ttdoc">Checks if a value is an instance of any of the specified types.</div><div class="ttdef"><b>Definition</b> isa.hxx:64</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">isa()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> type <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">without</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> </dd>
<dd>
<a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">that</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">returns</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">nullptr</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">on</a> failure </dd>
<dd>
<a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> null-safe <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a>   </dd></dl>

</div>
</div>
<a id="a9bacf7564f9a4ecea5eb6e3dbc8fd666" name="a9bacf7564f9a4ecea5eb6e3dbc8fd666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bacf7564f9a4ecea5eb6e3dbc8fd666">&#9670;&#160;</a></span>cast() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>) corelib::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked cast with assertion on type mismatch.   </p>
<p><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a> performs a type-safe downcast with runtime type checking and assertion. It first checks if the cast is valid using isa&lt;To&gt;(Val), then performs the cast. If the type check fails, it asserts in debug builds.</p>
<p>Supported types:</p><ul>
<li>References (const and non-const)</li>
<li>Pointers</li>
<li>std::unique_ptr (transfers ownership)</li>
</ul>
<p>Return type preserves const-correctness and reference/pointer semantics:</p><ul>
<li>const From&amp;  const To&amp;</li>
<li>From&amp;  To&amp;</li>
<li>From*  To*</li>
<li>unique_ptr&lt;From&gt;  unique_ptr&lt;To&gt;</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The target type </td></tr>
    <tr><td class="paramname">From</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value (type depends on input)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Asserts if Val is not an instance of To (debug::Assert) </dd>
<dd>
For pointers/unique_ptr, asserts Val is not null </dd>
<dd>
For unique_ptr, ownership is transferred (Val becomes empty) </dd>
<dd>
Uses decltype(auto) to preserve value categories</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">getDerived</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast pointer (asserts if not Derived)</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast reference</span></div>
<div class="line">Base &amp;<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">ref</a> = ...;</div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> &amp;<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dref</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">ref</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast unique_ptr (transfers ownership)</span></div>
<div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a> = ...;</div>
<div class="line">std::unique_ptr&lt;Derived&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(std::move(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a>));</div>
<div class="line"><span class="comment">// uptr is now empty</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Preserves const</span></div>
<div class="line"><span class="keyword">const</span> Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cbase</a> = ...;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cderived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cbase</a>);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">isa()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> type <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">without</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> </dd>
<dd>
<a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">that</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">returns</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">nullptr</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">on</a> failure </dd>
<dd>
<a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> null-safe <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a>   </dd></dl>

</div>
</div>
<a id="ab34745d6a4ac4a80b908cd8d4a5a1b09" name="ab34745d6a4ac4a80b908cd8d4a5a1b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34745d6a4ac4a80b908cd8d4a5a1b09">&#9670;&#160;</a></span>cast() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>) corelib::cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked cast with assertion on type mismatch.   </p>
<p><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a> performs a type-safe downcast with runtime type checking and assertion. It first checks if the cast is valid using isa&lt;To&gt;(Val), then performs the cast. If the type check fails, it asserts in debug builds.</p>
<p>Supported types:</p><ul>
<li>References (const and non-const)</li>
<li>Pointers</li>
<li>std::unique_ptr (transfers ownership)</li>
</ul>
<p>Return type preserves const-correctness and reference/pointer semantics:</p><ul>
<li>const From&amp;  const To&amp;</li>
<li>From&amp;  To&amp;</li>
<li>From*  To*</li>
<li>unique_ptr&lt;From&gt;  unique_ptr&lt;To&gt;</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The target type </td></tr>
    <tr><td class="paramname">From</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value (type depends on input)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Asserts if Val is not an instance of To (debug::Assert) </dd>
<dd>
For pointers/unique_ptr, asserts Val is not null </dd>
<dd>
For unique_ptr, ownership is transferred (Val becomes empty) </dd>
<dd>
Uses decltype(auto) to preserve value categories</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">getDerived</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast pointer (asserts if not Derived)</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast reference</span></div>
<div class="line">Base &amp;<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">ref</a> = ...;</div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> &amp;<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dref</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">ref</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast unique_ptr (transfers ownership)</span></div>
<div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a> = ...;</div>
<div class="line">std::unique_ptr&lt;Derived&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(std::move(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a>));</div>
<div class="line"><span class="comment">// uptr is now empty</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Preserves const</span></div>
<div class="line"><span class="keyword">const</span> Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cbase</a> = ...;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cderived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cbase</a>);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">isa()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> type <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">without</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> </dd>
<dd>
<a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">that</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">returns</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">nullptr</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">on</a> failure </dd>
<dd>
<a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> null-safe <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a>   </dd></dl>

</div>
</div>
<a id="a00ee56958fb3efe03056bd4185d3f231" name="a00ee56958fb3efe03056bd4185d3f231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ee56958fb3efe03056bd4185d3f231">&#9670;&#160;</a></span>cast_if_present() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::cast_if_present </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null-safe checked cast with assertion on type mismatch.   </p>
<p><a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> combines presence checking with checked casting. It first checks if Val is present (not null/empty), returning a null value if absent. If present, it unwraps the value and performs <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">cast&lt;X&gt;()</a> with assertion.</p>
<p>Useful for optional types and nullable pointers where you want null-safety but still want assertion on type mismatches for non-null values.</p>
<p>Supported types:</p><ul>
<li>std::optional (checks <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">has_value()</a>)</li>
<li>Pointers (checks != nullptr)</li>
<li>std::unique_ptr (checks != nullptr, transfers ownership)</li>
<li>Regular types (always present)</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, null/empty otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns failure value if Val is not present (no assertion) </dd>
<dd>
Asserts if Val is present but not of type X (debug::Assert) </dd>
<dd>
For unique_ptr, only transfers ownership if present and correct type</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">std::optional&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a> = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns std::nullopt if opt is empty, asserts if wrong type</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">result</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_if_present&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a>);</div>
<div class="line"> </div>
<div class="line">Base *ptr = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns nullptr if ptr is null, asserts if wrong type</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_if_present&lt;Derived&gt;</a>(ptr);</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a> = ...;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">duptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_if_present&lt;Derived&gt;</a>(std::move(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a>));</div>
<div class="line"><span class="comment">// If uptr was null: duptr is null, uptr unchanged</span></div>
<div class="line"><span class="comment">// If uptr was non-null and correct type: ownership transferred</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">with</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">assertion</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">no</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">null</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">check</a>) </dd>
<dd>
<a class="el" href="group__casting.html#ga460d2e78e8bfb779edc96b052b81ec33" title="Null-safe type checking with presence validation.">isa_and_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> type <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">and</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">presence</a> </dd>
<dd>
<a class="el" href="group__casting.html#gafefba7b24a26722051a1d828e0541f7c" title="Alias for cast_if_present() - null-safe checked cast.">cast_or_null()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">alias</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">to</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">this</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">function</a>   </dd></dl>

</div>
</div>
<a id="a7c8d1941223239a6b7fe4f96664eb99f" name="a7c8d1941223239a6b7fe4f96664eb99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8d1941223239a6b7fe4f96664eb99f">&#9670;&#160;</a></span>cast_if_present() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::cast_if_present </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null-safe checked cast with assertion on type mismatch.   </p>
<p><a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> combines presence checking with checked casting. It first checks if Val is present (not null/empty), returning a null value if absent. If present, it unwraps the value and performs <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">cast&lt;X&gt;()</a> with assertion.</p>
<p>Useful for optional types and nullable pointers where you want null-safety but still want assertion on type mismatches for non-null values.</p>
<p>Supported types:</p><ul>
<li>std::optional (checks <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">has_value()</a>)</li>
<li>Pointers (checks != nullptr)</li>
<li>std::unique_ptr (checks != nullptr, transfers ownership)</li>
<li>Regular types (always present)</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, null/empty otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns failure value if Val is not present (no assertion) </dd>
<dd>
Asserts if Val is present but not of type X (debug::Assert) </dd>
<dd>
For unique_ptr, only transfers ownership if present and correct type</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">std::optional&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a> = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns std::nullopt if opt is empty, asserts if wrong type</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">result</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_if_present&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a>);</div>
<div class="line"> </div>
<div class="line">Base *ptr = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns nullptr if ptr is null, asserts if wrong type</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_if_present&lt;Derived&gt;</a>(ptr);</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a> = ...;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">duptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_if_present&lt;Derived&gt;</a>(std::move(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a>));</div>
<div class="line"><span class="comment">// If uptr was null: duptr is null, uptr unchanged</span></div>
<div class="line"><span class="comment">// If uptr was non-null and correct type: ownership transferred</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">with</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">assertion</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">no</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">null</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">check</a>) </dd>
<dd>
<a class="el" href="group__casting.html#ga460d2e78e8bfb779edc96b052b81ec33" title="Null-safe type checking with presence validation.">isa_and_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> type <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">and</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">presence</a> </dd>
<dd>
<a class="el" href="group__casting.html#gafefba7b24a26722051a1d828e0541f7c" title="Alias for cast_if_present() - null-safe checked cast.">cast_or_null()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">alias</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">to</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">this</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">function</a>   </dd></dl>

</div>
</div>
<a id="a2d8178a9ace3f4fd4e65e8ecb065e86c" name="a2d8178a9ace3f4fd4e65e8ecb065e86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8178a9ace3f4fd4e65e8ecb065e86c">&#9670;&#160;</a></span>cast_if_present() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::cast_if_present </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null-safe checked cast with assertion on type mismatch.   </p>
<p><a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> combines presence checking with checked casting. It first checks if Val is present (not null/empty), returning a null value if absent. If present, it unwraps the value and performs <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">cast&lt;X&gt;()</a> with assertion.</p>
<p>Useful for optional types and nullable pointers where you want null-safety but still want assertion on type mismatches for non-null values.</p>
<p>Supported types:</p><ul>
<li>std::optional (checks <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">has_value()</a>)</li>
<li>Pointers (checks != nullptr)</li>
<li>std::unique_ptr (checks != nullptr, transfers ownership)</li>
<li>Regular types (always present)</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, null/empty otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns failure value if Val is not present (no assertion) </dd>
<dd>
Asserts if Val is present but not of type X (debug::Assert) </dd>
<dd>
For unique_ptr, only transfers ownership if present and correct type</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">std::optional&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a> = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns std::nullopt if opt is empty, asserts if wrong type</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">result</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_if_present&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a>);</div>
<div class="line"> </div>
<div class="line">Base *ptr = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns nullptr if ptr is null, asserts if wrong type</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_if_present&lt;Derived&gt;</a>(ptr);</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a> = ...;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">duptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_if_present&lt;Derived&gt;</a>(std::move(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a>));</div>
<div class="line"><span class="comment">// If uptr was null: duptr is null, uptr unchanged</span></div>
<div class="line"><span class="comment">// If uptr was non-null and correct type: ownership transferred</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">with</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">assertion</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">no</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">null</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">check</a>) </dd>
<dd>
<a class="el" href="group__casting.html#ga460d2e78e8bfb779edc96b052b81ec33" title="Null-safe type checking with presence validation.">isa_and_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checking</a> type <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">and</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">presence</a> </dd>
<dd>
<a class="el" href="group__casting.html#gafefba7b24a26722051a1d828e0541f7c" title="Alias for cast_if_present() - null-safe checked cast.">cast_or_null()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">alias</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">to</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">this</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">function</a>   </dd></dl>

</div>
</div>
<a id="aea0ce038c14cb139d6bcd2901f0d9ab0" name="aea0ce038c14cb139d6bcd2901f0d9ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0ce038c14cb139d6bcd2901f0d9ab0">&#9670;&#160;</a></span>cast_or_null() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::cast_or_null </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> - null-safe checked cast.   </p>
<p><a class="el" href="group__casting.html#gafefba7b24a26722051a1d828e0541f7c" title="Alias for cast_if_present() - null-safe checked cast.">cast_or_null()</a> is an alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a>, providing a more intuitive name for pointer-based casting. It returns nullptr if the cast fails or if the input is null.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, null/empty otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Identical to <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> </dd>
<dd>
Asserts if Val is non-null but not of type X</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns nullptr if base is null or wrong type (with assertion)</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_or_null&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a>) {</div>
<div class="line">    <span class="comment">// Safe to use derived</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">the</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">underlying</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">implementation</a>   </dd></dl>

</div>
</div>
<a id="ae6803a28d82c6018ac8eea72d865da48" name="ae6803a28d82c6018ac8eea72d865da48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6803a28d82c6018ac8eea72d865da48">&#9670;&#160;</a></span>cast_or_null() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::cast_or_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> - null-safe checked cast.   </p>
<p><a class="el" href="group__casting.html#gafefba7b24a26722051a1d828e0541f7c" title="Alias for cast_if_present() - null-safe checked cast.">cast_or_null()</a> is an alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a>, providing a more intuitive name for pointer-based casting. It returns nullptr if the cast fails or if the input is null.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, null/empty otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Identical to <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> </dd>
<dd>
Asserts if Val is non-null but not of type X</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns nullptr if base is null or wrong type (with assertion)</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_or_null&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a>) {</div>
<div class="line">    <span class="comment">// Safe to use derived</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">the</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">underlying</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">implementation</a>   </dd></dl>

</div>
</div>
<a id="a185551f91b6505cdb17df6403766a502" name="a185551f91b6505cdb17df6403766a502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185551f91b6505cdb17df6403766a502">&#9670;&#160;</a></span>cast_or_null() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::cast_or_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> - null-safe checked cast.   </p>
<p><a class="el" href="group__casting.html#gafefba7b24a26722051a1d828e0541f7c" title="Alias for cast_if_present() - null-safe checked cast.">cast_or_null()</a> is an alias for <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a>, providing a more intuitive name for pointer-based casting. It returns nullptr if the cast fails or if the input is null.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, null/empty otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Identical to <a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> </dd>
<dd>
Asserts if Val is non-null but not of type X</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns nullptr if base is null or wrong type (with assertion)</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">cast_or_null&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a>) {</div>
<div class="line">    <span class="comment">// Safe to use derived</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga7cf1ac44d2a0a7830f22480b836e1801" title="Null-safe checked cast with assertion on type mismatch.">cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">the</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">underlying</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">implementation</a>   </dd></dl>

</div>
</div>
<a id="a750e97235651993722aacfb4ae28c316" name="a750e97235651993722aacfb4ae28c316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750e97235651993722aacfb4ae28c316">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>) corelib::dyn_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast that returns nullptr on type mismatch.   </p>
<p><a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> performs a type-safe downcast with runtime type checking. Unlike <a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a>, it returns a null value (nullptr for pointers, empty for unique_ptr) if the cast fails, rather than asserting. This provides a safe way to attempt casts where the type is uncertain.</p>
<p>Supported types:</p><ul>
<li>References (const and non-const) - returns reference or null reference (implementation defined)</li>
<li>Pointers - returns pointer or nullptr</li>
<li>std::unique_ptr - returns unique_ptr or empty unique_ptr</li>
</ul>
<p>Return type preserves const-correctness:</p><ul>
<li>const From&amp;  const To&amp; or null</li>
<li>From&amp;  To&amp; or null</li>
<li>From*  To* or nullptr</li>
<li>unique_ptr&lt;From&gt;&amp;  unique_ptr&lt;To&gt; or empty</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The target type </td></tr>
    <tr><td class="paramname">From</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if type matches, nullptr/null value otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Asserts if Val is null (use dyn_cast_or_null for null-safe version) </dd>
<dd>
For pointers: returns nullptr on failure (safe to check) </dd>
<dd>
For unique_ptr: transfers ownership only if cast succeeds </dd>
<dd>
Uses decltype(auto) to preserve value categories</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">getBase</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Safe cast - returns nullptr if not Derived</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>)) {</div>
<div class="line">    <span class="comment">// base was a Derived, use it</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// base was some other type</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Works with unique_ptr</span></div>
<div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a> = ...;</div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a>)) {</div>
<div class="line">    <span class="comment">// Cast succeeded, ownership transferred</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Cast failed, uptr still owns the object</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checked</a> <a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">with</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">assertion</a> </dd>
<dd>
<a class="el" href="group__casting.html#ga88d657e52bfcc3ea71532bc19b5b1575" title="Alias for dyn_cast_if_present() - null-safe dynamic cast.">dyn_cast_or_null()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> null-safe <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">version</a> </dd>
<dd>
<a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> presence-checking <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">version</a>   </dd></dl>

</div>
</div>
<a id="a64b832881676b821a3a725097329d4fa" name="a64b832881676b821a3a725097329d4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b832881676b821a3a725097329d4fa">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>) corelib::dyn_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast that returns nullptr on type mismatch.   </p>
<p><a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> performs a type-safe downcast with runtime type checking. Unlike <a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a>, it returns a null value (nullptr for pointers, empty for unique_ptr) if the cast fails, rather than asserting. This provides a safe way to attempt casts where the type is uncertain.</p>
<p>Supported types:</p><ul>
<li>References (const and non-const) - returns reference or null reference (implementation defined)</li>
<li>Pointers - returns pointer or nullptr</li>
<li>std::unique_ptr - returns unique_ptr or empty unique_ptr</li>
</ul>
<p>Return type preserves const-correctness:</p><ul>
<li>const From&amp;  const To&amp; or null</li>
<li>From&amp;  To&amp; or null</li>
<li>From*  To* or nullptr</li>
<li>unique_ptr&lt;From&gt;&amp;  unique_ptr&lt;To&gt; or empty</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The target type </td></tr>
    <tr><td class="paramname">From</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if type matches, nullptr/null value otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Asserts if Val is null (use dyn_cast_or_null for null-safe version) </dd>
<dd>
For pointers: returns nullptr on failure (safe to check) </dd>
<dd>
For unique_ptr: transfers ownership only if cast succeeds </dd>
<dd>
Uses decltype(auto) to preserve value categories</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">getBase</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Safe cast - returns nullptr if not Derived</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>)) {</div>
<div class="line">    <span class="comment">// base was a Derived, use it</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// base was some other type</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Works with unique_ptr</span></div>
<div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a> = ...;</div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a>)) {</div>
<div class="line">    <span class="comment">// Cast succeeded, ownership transferred</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Cast failed, uptr still owns the object</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checked</a> <a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">with</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">assertion</a> </dd>
<dd>
<a class="el" href="group__casting.html#ga88d657e52bfcc3ea71532bc19b5b1575" title="Alias for dyn_cast_if_present() - null-safe dynamic cast.">dyn_cast_or_null()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> null-safe <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">version</a> </dd>
<dd>
<a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> presence-checking <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">version</a>   </dd></dl>

</div>
</div>
<a id="aade9c253cc43f65206215d40cabd1b02" name="aade9c253cc43f65206215d40cabd1b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade9c253cc43f65206215d40cabd1b02">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">To</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">typename</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">decltype</a>(<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a>) corelib::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">From</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast that returns nullptr on type mismatch.   </p>
<p><a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> performs a type-safe downcast with runtime type checking. Unlike <a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a>, it returns a null value (nullptr for pointers, empty for unique_ptr) if the cast fails, rather than asserting. This provides a safe way to attempt casts where the type is uncertain.</p>
<p>Supported types:</p><ul>
<li>References (const and non-const) - returns reference or null reference (implementation defined)</li>
<li>Pointers - returns pointer or nullptr</li>
<li>std::unique_ptr - returns unique_ptr or empty unique_ptr</li>
</ul>
<p>Return type preserves const-correctness:</p><ul>
<li>const From&amp;  const To&amp; or null</li>
<li>From&amp;  To&amp; or null</li>
<li>From*  To* or nullptr</li>
<li>unique_ptr&lt;From&gt;&amp;  unique_ptr&lt;To&gt; or empty</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The target type </td></tr>
    <tr><td class="paramname">From</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if type matches, nullptr/null value otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Asserts if Val is null (use dyn_cast_or_null for null-safe version) </dd>
<dd>
For pointers: returns nullptr on failure (safe to check) </dd>
<dd>
For unique_ptr: transfers ownership only if cast succeeds </dd>
<dd>
Uses decltype(auto) to preserve value categories</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">getBase</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Safe cast - returns nullptr if not Derived</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>)) {</div>
<div class="line">    <span class="comment">// base was a Derived, use it</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// base was some other type</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Works with unique_ptr</span></div>
<div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a> = ...;</div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dptr</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">uptr</a>)) {</div>
<div class="line">    <span class="comment">// Cast succeeded, ownership transferred</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Cast failed, uptr still owns the object</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">checked</a> <a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">with</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">assertion</a> </dd>
<dd>
<a class="el" href="group__casting.html#ga88d657e52bfcc3ea71532bc19b5b1575" title="Alias for dyn_cast_if_present() - null-safe dynamic cast.">dyn_cast_or_null()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> null-safe <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">version</a> </dd>
<dd>
<a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> presence-checking <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">version</a>   </dd></dl>

</div>
</div>
<a id="a81a3460f3a07f4029776ed8503473b21" name="a81a3460f3a07f4029776ed8503473b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a3460f3a07f4029776ed8503473b21">&#9670;&#160;</a></span>dyn_cast_if_present() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::dyn_cast_if_present </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Null-safe dynamic cast with presence checking.   </p>
<p><a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> combines presence checking with dynamic casting. It first checks if Val is present (not null/empty), then performs <a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> on the unwrapped value. Returns null/empty if Val is not present or if the cast fails.</p>
<p>This is the safest casting operation - it never asserts and handles both null values and type mismatches gracefully.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, null/empty otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No assertions - safe to call on null/empty values </dd>
<dd>
Returns null if Val is not present (no type check performed) </dd>
<dd>
Returns null if Val is present but wrong type</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Safe even if base is nullptr</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast_if_present&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>)) {</div>
<div class="line">    <span class="comment">// base was non-null AND was a Derived</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::optional&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a> = ...;</div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast_if_present&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a>)) {</div>
<div class="line">    <span class="comment">// opt had value AND was Derived</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">dynamic</a> <a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">asserts</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">on</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">null</a>) </dd>
<dd>
<a class="el" href="group__casting.html#ga88d657e52bfcc3ea71532bc19b5b1575" title="Alias for dyn_cast_if_present() - null-safe dynamic cast.">dyn_cast_or_null()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">alias</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">to</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">this</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">function</a>   </dd></dl>

</div>
</div>
<a id="a2ca5b5fc19f14cf3d6fd9ab2eb68ab3d" name="a2ca5b5fc19f14cf3d6fd9ab2eb68ab3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca5b5fc19f14cf3d6fd9ab2eb68ab3d">&#9670;&#160;</a></span>dyn_cast_if_present() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::dyn_cast_if_present </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Null-safe dynamic cast with presence checking.   </p>
<p><a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> combines presence checking with dynamic casting. It first checks if Val is present (not null/empty), then performs <a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> on the unwrapped value. Returns null/empty if Val is not present or if the cast fails.</p>
<p>This is the safest casting operation - it never asserts and handles both null values and type mismatches gracefully.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, null/empty otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No assertions - safe to call on null/empty values </dd>
<dd>
Returns null if Val is not present (no type check performed) </dd>
<dd>
Returns null if Val is present but wrong type</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Safe even if base is nullptr</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast_if_present&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>)) {</div>
<div class="line">    <span class="comment">// base was non-null AND was a Derived</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::optional&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a> = ...;</div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast_if_present&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">opt</a>)) {</div>
<div class="line">    <span class="comment">// opt had value AND was Derived</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">dynamic</a> <a class="el" href="group__casting.html#ga0612fde000a014ae055fdc0ef1c5f06a" title="Checked cast with assertion on type mismatch.">cast</a> (<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">asserts</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">on</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">null</a>) </dd>
<dd>
<a class="el" href="group__casting.html#ga88d657e52bfcc3ea71532bc19b5b1575" title="Alias for dyn_cast_if_present() - null-safe dynamic cast.">dyn_cast_or_null()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">alias</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">to</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">this</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">function</a>   </dd></dl>

</div>
</div>
<a id="ad3279a5fff48ff7c5c5a2861a0676a1c" name="ad3279a5fff48ff7c5c5a2861a0676a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3279a5fff48ff7c5c5a2861a0676a1c">&#9670;&#160;</a></span>dyn_cast_or_null() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> - null-safe dynamic cast.   </p>
<p><a class="el" href="group__casting.html#ga88d657e52bfcc3ea71532bc19b5b1575" title="Alias for dyn_cast_if_present() - null-safe dynamic cast.">dyn_cast_or_null()</a> is an alias for <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a>, providing a more intuitive name for pointer-based casting. It returns nullptr if the cast fails or if the input is null.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, nullptr otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Identical to <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> </dd>
<dd>
No assertions - safe for null inputs and type mismatches</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns nullptr if base is null OR wrong type</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast_or_null&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a>) {</div>
<div class="line">    <span class="comment">// Safe to use</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">the</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">underlying</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">implementation</a>   </dd></dl>

</div>
</div>
<a id="a616ff1074888b3ca6933dc4b8eff8a2a" name="a616ff1074888b3ca6933dc4b8eff8a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616ff1074888b3ca6933dc4b8eff8a2a">&#9670;&#160;</a></span>dyn_cast_or_null() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> - null-safe dynamic cast.   </p>
<p><a class="el" href="group__casting.html#ga88d657e52bfcc3ea71532bc19b5b1575" title="Alias for dyn_cast_if_present() - null-safe dynamic cast.">dyn_cast_or_null()</a> is an alias for <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a>, providing a more intuitive name for pointer-based casting. It returns nullptr if the cast fails or if the input is null.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The value to check and cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Casted value if present and correct type, nullptr otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Identical to <a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> </dd>
<dd>
No assertions - safe for null inputs and type mismatches</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Base *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns nullptr if base is null OR wrong type</span></div>
<div class="line"><a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Derived</a> *<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">dyn_cast_or_null&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a>) {</div>
<div class="line">    <span class="comment">// Safe to use</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga1b32b071c53b4f77dbbf3a4300db5b5c" title="Null-safe dynamic cast with presence checking.">dyn_cast_if_present()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">the</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">underlying</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">implementation</a>   </dd></dl>

</div>
</div>
<a id="aac4a4863f86ade1c8f9e3b7cf5a5f5f1" name="aac4a4863f86ade1c8f9e3b7cf5a5f5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4a4863f86ade1c8f9e3b7cf5a5f5f1">&#9670;&#160;</a></span>unique_dyn_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::unique_dyn_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialized dynamic cast for std::unique_ptr with ownership transfer.   </p>
<p><a class="el" href="group__casting.html#ga1b6434dfe4978d4921d20eecf9959c36" title="Specialized dynamic cast for std::unique_ptr with ownership transfer.">unique_dyn_cast()</a> performs a type-safe cast of unique_ptr with ownership semantics. If the cast succeeds, ownership is transferred to the returned unique_ptr. If the cast fails, the original unique_ptr retains ownership and an empty unique_ptr is returned.</p>
<p>This function asserts that Val is non-null (use unique_dyn_cast_or_null for null-safe version).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The unique_ptr to cast (passed by reference or rvalue) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr&lt;X&gt; if cast succeeds, empty unique_ptr otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Asserts if Val is null </dd>
<dd>
Ownership transferred only if cast succeeds </dd>
<dd>
Val becomes empty if cast succeeds, retains ownership if cast fails</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">getDerived</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cast succeeds: ownership transferred</span></div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">unique_dyn_cast&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>)) {</div>
<div class="line">    <span class="comment">// base is now empty, derived owns the object</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Cast failed, base still owns the object</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#gae484b007072d62449ecda4be20b42179" title="Dynamic cast that returns nullptr on type mismatch.">dyn_cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">general</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">dynamic</a> <a class="el" href="group__casting.html" title="RTTI-free casting utilities inspired by LLVM.">Casting Module</a> </dd>
<dd>
<a class="el" href="group__casting.html#ga90e00c9795d47bfe31f4bf1a1a3aac6f" title="Null-safe unique_ptr dynamic cast with ownership transfer.">unique_dyn_cast_or_null()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> null-safe <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">version</a>   </dd></dl>

</div>
</div>
<a id="a6ba87a9d9f2ec01ce96042af88df2918" name="a6ba87a9d9f2ec01ce96042af88df2918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba87a9d9f2ec01ce96042af88df2918">&#9670;&#160;</a></span>unique_dyn_cast_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">X</a> , <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">class</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">auto</a> corelib::unique_dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">Y</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null-safe unique_ptr dynamic cast with ownership transfer.   </p>
<p><a class="el" href="group__casting.html#ga90e00c9795d47bfe31f4bf1a1a3aac6f" title="Null-safe unique_ptr dynamic cast with ownership transfer.">unique_dyn_cast_or_null()</a> is the null-safe version of <a class="el" href="group__casting.html#ga1b6434dfe4978d4921d20eecf9959c36" title="Specialized dynamic cast for std::unique_ptr with ownership transfer.">unique_dyn_cast()</a>. It checks if Val is null before attempting the cast. If null, returns nullptr immediately without assertion. Otherwise performs the dynamic cast.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>The target type </td></tr>
    <tr><td class="paramname">Y</td><td>The source type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Val</td><td>The unique_ptr to cast (may be null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr&lt;X&gt; if non-null and cast succeeds, nullptr otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No assertion - safe to call on null unique_ptr </dd>
<dd>
Ownership transferred only if non-null and cast succeeds</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">std::unique_ptr&lt;Base&gt; <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a> = ...;  <span class="comment">// May be nullptr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Safe even if base is nullptr</span></div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">derived</a> = <a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">unique_dyn_cast_or_null&lt;Derived&gt;</a>(<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>)) {</div>
<div class="line">    <span class="comment">// base was non-null AND was Derived, ownership transferred</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// base was null OR wrong type</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8">base</a>) {</div>
<div class="line">        <span class="comment">// base still owns the object (wrong type)</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__casting.html#ga1b6434dfe4978d4921d20eecf9959c36" title="Specialized dynamic cast for std::unique_ptr with ownership transfer.">unique_dyn_cast()</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">for</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">version</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">that</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">asserts</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">on</a> <a class="el" href="group__casting.html#ga21d42fef17770f4f775ad655ab85e2b8" title="Checks if a value is an instance of any of the specified types.">null</a>   </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecorelib.html">corelib</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
